---
title: "Interviewing"
category: Daily
author: Daniel Nguyen
tags: ['#Daily']
date: 2020-01-02
thumbnailText: Daily
---

# HR Questions

### 1. **Can you introduce yourself?**

> Who you are, your role, and your core skills

### 2. **What do you know about our company?**

> Company product/domain + why it interests you

### 3. **Can you describe a recent project you’ve been working on?**

> Your role, tech stack, and impact

### 4. **What interests you about this position?**

> Alignment between the role, your skills, and growth goals

### 5. **When you get stuck and can’t solve a problem, how do you proceed?**

> Break down the problem → research → ask for help clearly

### 6. **How do you learn and improve your skills?**

> Practice, documentation, feedback, and continuous learning

### 7. **How do you handle working on a challenging feature?**

> Understand requirements → split into small tasks → iterate

### 8. **What tools do you use to manage your work?**

> Task tracking, version control, and communication tools

### 9. **When starting a project, how do you plan and organize your work to ensure completion?**

> Clarify requirements → plan tasks → set priorities and milestones

### 10. **How do you handle stress and pressure at work?**

> Prioritization, communication, and staying organized

### 11. **What are your strengths?**

> Problem-solving, responsibility, and willingness to learn

### 12. **What are your weaknesses?**

> A real but manageable weakness + improvement effort

### 13. **What is your preferred working or management style?**

> Clear goals, open communication, and collaboration

### 14. **Have you ever mentored a junior team member? What is your leadership style?**

> Supportive, knowledge-sharing, and collaborative

### 15. **Where do you see yourself in five years?**

> Growth into a stronger, more impactful engineer

### 16. **What are your salary expectations?**

> Market-based range + openness to discussion

#  React Technical

### 1. Can you explain the React component lifecycle?

> Mounting      
> Updating      
> Unmounting        

> * What causes a component to re-render?     
> State changes, prop changes, or parent re-renders

> * What is controlled vs uncontrolled components
> Controlled components have their state managed by React (via props/state)
> Uncontrolled components manage their own state (via refs/DOM)

> * What is a Pure Component?
> A component that renders the same output for the same props/state.

> * What is a Higher Order Component (HOC)?
> A function that takes a component and returns a new component with enhanced behavior.

> * What is reconciliation in React?     
> React’s process of diffing the virtual DOM and updating the real DOM efficiently.

> * What is the difference between `useEffect()` and `useLayoutEffect()`?       
> `useEffect` → runs after paint (non-blocking)     
> `useLayoutEffect` → runs before paint (blocking)

> * Why is useLayoutEffect considered dangerous if misused?     
> It can block rendering and cause performance issues if it contains heavy computations.

> * Give a real-world use case for useLayoutEffect     
> Measuring DOM elements before paint (e.g., calculating sizes for animations)

> * How does Concurrent Rendering affect lifecycle behavior?     
> It allows React to interrupt rendering, which can change when effects run and improve responsiveness.

### What is your error-handling strategy in production apps?

> Use Error Boundaries to catch rendering errors.   
> try/catch in async code.      

> * What are Error Boundaries?      
> React components that catch JavaScript errors in their child component tree.      

> * What errors do Error Boundaries NOT catch?      
> Event handlers, async code, server-side rendering.        

> * How do you handle errors in event handlers?     
> Use try/catch blocks within the event handler functions.      

> * How do you handle errors with React Query?      
> Use onError callbacks and error states provided by React Query hooks.     

> * Different between isError, error?   
> isError is a boolean flag;    
> error contains the actual error object/details.   

### 3. How do you render a list in React?

> Use `Array.map()` to create elements from data arrays.        
> Use unique `key` props for each item.

> * Why are keys important in React lists?        
> Keys help React identify which items have changed, added, or removed for efficient updates.

> * What makes a good key?        
> Unique, stable identifiers (e.g., IDs). Avoid using indexes if the list can change

> * Can you use array index as a key?        
> Only if the list is static and won’t change order or have items added/removed.

> * What happens if you don’t provide keys?        
> React will use indexes by default, which can lead to inefficient updates and bugs.

> * How do you optimize large lists?        
> Use virtualization libraries (e.g., react-window) to render only visible items.

> * How useId() differs from key?
* `useId` generates a new value per render
* Keys must be stable across renders

### 4. What is the Context API?

> A way to share state globally without prop drilling.        
> Use `React.createContext()`, `Provider`, and `useContext()`.

> * When should you use Context?        
> For global state like themes, auth, or settings.

> * How Context Works        
> Create a context with `React.createContext()`. Wrap components with `Provider` to supply values. Use `useContext()` to consume values.

> * Performance Considerations        
> Context updates re-render all consumers. Optimize by splitting contexts or memoizing values.        

### 5. What causes performance issues in React apps?

> Unnecessary re-renders, large component trees, heavy computations in render.

> * How do you optimize it?
> Memoization (`React.memo`, `useMemo`, `useCallback`)    
> Split components & state    
> Virtualize large lists    
> Optimize Context usage    

> * How do you detect and diagnose **unnecessary re-renders**?        
> React DevTools Profiler        
> Console logging renders        

> * The different between `React.memo()`, `useMemo()`, and `useCallback()`?        
> `React.memo` → memoizes entire components        
> `useMemo` → memoizes computed values        
> `useCallback` → memoizes functions        

> * When should you use `React.memo()` and when should you avoid it?        
> Use it when re-renders are expensive and props are stable        
> Avoid when renders are cheap or props change frequently        

> * How would you optimize **rendering a list with thousands of items**?        
> List virtualization (`react-window`)        
> Memoized row components        

> * When would you use `useDeferredValue()` or `useTransition()`?       
> For deferring non-urgent updates to keep the UI responsive during heavy rendering.        
> `useDeferredValue` delay rendering non-urgent derived values. Example: filtering a large list while typing.   
> `useTransition` mark updates as low-priority. Example: switching tabs while fetching/rendering data.    

### 6. What is React Testing Library (RTL)?

> A testing library focused on testing React components via the DOM, simulating real user interactions.

> * How do you find elements in RTL?
> Use accessible queries like `getByRole`, `getByLabelText`, `getByText`.

> * Why is getByRole preferred?
> It reflects how users interact with the app and improves test reliability.

> * What’s the difference between getBy, queryBy, and findBy?
> `getBy` throws an error if not found (synchronous)    
> `queryBy` returns null if not found (synchronous)    
> `findBy` returns a promise and waits for the element (asynchronous)

> * Why prefer userEvent over fireEvent?
> `userEvent` simulates real user interactions more accurately (e.g., typing, clicking).

> * Why do we avoid testing implementation details?
> Tests should focus on user-visible behavior, not internal component structure.

> * When should you mock and when not?
> Mock external dependencies (APIs, timers) but avoid mocking DOM/browser APIs unless necessary.

> * Why use MSW instead of mocking fetch?
> MSW mocks at the network level, providing realistic responses and reusable mocks across tests.

> * What’s the biggest mistake people make with RTL?
> Testing implementation details instead of user behavior.
> Manual ReactDOM testing

> * What is JSDOM?
> JSDOM is a JavaScript implementation of the DOM and HTML standards, used for testing React components in a Node.js environment without a real browser.

> * Which browser APIs are missing or incomplete in **JSDOM**?
> `ResizeObserver`, `matchMedia`, `Clipboard`

> * Why is mocking browser APIs called **“poking a hole in reality”**?
> Mocks reduce realism; **integration/e2e tests should minimize mocking** to better reflect real user environments.

> * When testing forms, what user behaviors should be simulated?
> Typing, clicking, focusing, submitting, and validation feedback, not direct state manipulation.

> * Which matcher do you use?
> `toBeInTheDocument()` to check presence in the DOM.
> `toHaveTextContent()` to verify text content.
> `toHaveAttribute()` to check element attributes.
> `toBeVisible()` to ensure element visibility.

### 7. What patterns do you apply in your React project?

> Composition -> avoid prop drilling
> Latest ref -> store the latest value
> Compound components -> shared state
> Prop collection -> full control

> * Why use Component Composition instead of inheritance?
> It lets components receive behavior and UI via children instead of passing props deeply, improving flexibility and reuse.
> Example use cases: tabs, layouts, dropdowns.

> * Why store the latest value in useRef instead of state for async logic?
> Refs update without triggering re-renders, making them ideal for async callbacks that need the latest value.
> Example use cases: timers, debounce, async callbacks.

> * What are Compound Components in React?
> A pattern where related components share state via Context, allowing flexible APIs without prop drilling.
> Example use cases: tabs, accordions, dropdowns.
> * How does the **state reducer pattern** customize behavior?
> **It lets consumers intercept and modify state transitions without changing internal component logic.**

> * Advantage of a Prop Getter over prop collection?
> Prop getters give consumers full control while still applying required logic, preventing accidental overrides.
> Example use cases: custom inputs, dropdowns, modals.

#  State Management

### 1. **How do you decide whether a piece of state belongs in Redux, React Query, or local component state?**

> * UI state -> Local state
> * Global state -> Redux 
> * Server data ->	React Query
> * Auth -> Context + storage

### 2. What is Redux Toolkit?

> * UI → Action → Middleware → Reducer → Store → UI
> * Redux Toolkit is recommended way to write Redux that reduces boilerplate and enforces best practices.

> - What does createSlice do?   
>   Combines state, reducers, and actions in one place

> * How can RTK allow “mutating” state?     
>  Uses Immer to convert mutations to immutable updates

> * What is configureStore?     
> Sets up the Redux store with good defaults (DevTools, middleware)

> * How you use middleware in RTK?      
>  Use with libraries redux-logger

> * What is createAsyncThunk?       
>  Simplifies async logic (CRUD, single API calls)

> * Can one slice respond to actions from another slice?        
>  Yes, using extraReducers

> * extraReducers vs reducers?      
> reducers handle this slice’s actions; extraReducers handle external actions

### 3. What is Redux Saga?

> * Middleware for handling complex async side effects in Redux applications.

> * Why does Redux-Saga use generator functions?        
> Generators allow pausing and resuming async logic.

> * What is a saga?     
> A saga is a generator function that handles side effects.

> * Difference between call and put and fork?       
> call runs a function, put dispatches an action.
> call is blocking—the saga waits for the function to complete. 
> fork is non-blocking and runs the task in the background, allowing concurrent execution.

> * What does takeLatest do?        
> Runs only the latest action, cancels previous ones.

> * Difference between takeEvery, takeLatest, and takeLeading?      
> takeEvery runs for every action.      
> takeLatest runs only the latest action, cancelling previous ones.     
> takeLeading runs only the first action, ignoring subsequent ones until it completes.      

> * How do you run multiple API calls in parallel?      
> Use yield all([...]) to run effects concurrently.     

> * How do you handle errors in Redux-Saga?     
> Use try/catch blocks inside sagas.        

> * How do you cancel a running saga?       
> Using takeLatest or cancel.       

> * What is race and when would you use it?     
> race runs multiple effects and completes when the first one finishes.     

> * Why should reducers remain pure when using Redux-Saga?      
> To ensure predictable state updates and maintainability.

### 4. **What is React Query?**

> * Data-fetching library for React that simplifies server state management.    
> React Query manages server state—fetching, caching, and syncing data with the server.

> * What is a mutation?     
> A mutation is an operation that modifies server data (POST, PUT, DELETE).

> * What are query keys and why are they important?     
> Query keys uniquely identify queries for caching and refetching.

> * How does React Query handle caching?        
> Caches data based on query keys and provides stale-while-revalidate behavior.

> * What is staleTime?      
> Duration data is considered fresh before being marked stale.

> * What is cacheTime / gcTime?     
> Duration unused data remains in cache before garbage collection.

> * When does React Query refetch automatically?        
> On window focus, network reconnect, or interval-based refetching.

> * What does enabled do?       
> Controls whether a query should automatically run.

> * Difference between isLoading and isFetching?        
> isLoading is true on the initial fetch; isFetching is true on any fetch (initial or subsequent).

> * How do you invalidate queries?      
> Use queryClient.invalidateQueries(queryKey) to refetch data.

> * How do you perform optimistic updates?      
> Update the UI immediately, then roll back if the mutation fails.

> * How do you handle pagination and infinite scrolling?        
> Use useInfiniteQuery for fetching paginated data.

> * How do you handle mutation errors?      
> Use onError callback in useMutation to handle errors.

#  JavaScript

### 1. What is a `closure` in JavaScript?

> How does it help with data encapsulation and state preservation?

### 2. What is `hoisting`?

> How does it behave differently for:
> 
> * `var`
> * `let`
> * `const`
> * function declarations vs function expressions?

### 3. How does `this` work in JavaScript?

> How is it determined in:
> 
> * normal functions
> * arrow functions
> * event handlers
> * class methods?

### 4. What is the **JavaScript `event loop`**?

> Explain the execution order of:
>
> * synchronous code
> * microtasks (`Promise.then`, `queueMicrotask`)
> * macrotasks (`setTimeout`, `setInterval`)

### 5. What are **`microtasks vs macrotasks`**?

> Why do Promises run before `setTimeout`?

### 6. What are common **`asynchronous patterns`** in JavaScript?

> When should you use:
> 
> * callbacks
> * Promises
> * `async/await`?

### 7. What is **`debouncing`** and **`throttling`**?

> What problem do they solve, and what is the difference?

### 8. What is the difference between **`==` and `===`**?

> Explain type coercion with examples.

### 9. What is **`prototype inheritance`**?

> How does the prototype chain work in JavaScript?

### 10. What is the difference between **`null` and `undefined`**?

### 11. What is a **`shallow copy` vs `deep copy`**?

> How can you create them in JavaScript?

### 12. What is **`immutability`**?

> Why is it important in modern frameworks like React?

### 13. How does **`scope`** work in JavaScript?

> Explain:
>
> * global scope
> * function scope
> * block scope

### 14. What happens when you use `new` with a function?

> Explain constructor behavior step by step.

### 15. What is **`memory leak`** in JavaScript?

> What are common causes and how can you prevent them?

#  TypeScript

### 1. What are the **main differences between TypeScript and JavaScript**?

> * What problems does TypeScript solve?
> * Is TypeScript required at runtime?

### 2. How does **TypeScript improve code safety at compile time**?

> * What kinds of errors can it catch before runtime?
> * How does static typing help large codebases?

### 3. What are **interfaces** in TypeScript?

> * How do interfaces work?
> * Can interfaces be extended or merged?

### 4. What are **type aliases (`type`)** in TypeScript?

> * What can `type` represent that `interface` cannot?

### 5. When should you use **`interface` vs `type`**?

> * Which one is better for public APIs?
> * Which one works better with unions?

### 6. What are **generic types** in TypeScript?

> * Why are generics important?
> * How do generics improve reusability and type safety?

### 7. What is **type inference** in TypeScript?

> * When does TypeScript infer types automatically?
> * When should you explicitly define types?

### 8. What are **union and intersection types**?

> * How do they differ?
> * Give real-world examples.

### 9. What is **`any` vs `unknown`**?

> * Why is `unknown` safer?
> * When should `any` be avoided?

### 10. What is **`never`** in TypeScript?

> * When does TypeScript infer `never`?
> * Why is it useful?

### 11. What are **optional properties** and **readonly**?
### 12. What is **strict mode** (`strict: true`)?
### 13. How does TypeScript work with **third-party JS libraries**?
### 14. What are **utility types** (`Partial`, `Pick`, `Omit`)?

# CSS/SCSS/Tailwind

### 1. What are CSS pre-processors?

> how do features like variables, nesting, and mixins (e.g., in Sass or Less) improve maintainability and scalability in large applications?

### 2. What is Tailwind CSS, and how is it different from traditional CSS or SCSS?

> Why is it called a utility-first framework?

### 3. What are the advantages and disadvantages of Tailwind CSS?

> When would you choose Tailwind over SCSS or CSS Modules?

### 4. How does Tailwind CSS handle responsive design?

> Explain breakpoints and mobile-first styling.

### 5. How does dark mode work in Tailwind CSS?

> Explain media vs class strategies.

### 6. What is @apply, and when should (or shouldn’t) you use it?

> What problems can misuse of @apply cause?

### 7. How do you manage reusable components and consistency in Tailwind?

> Compare:
> 
> * utility composition
> * component abstraction
> * design tokens

### 8. How do you optimize Tailwind CSS for production?

> Explain tree-shaking and purging unused styles.

### 9. How do you ensure accessibility (a11y)?

> Focus on color contrast, focus states, and semantic HTML.

# CI/CD

### 1. Can you describe your **CI/CD experience**?

> * What CI/CD tools have you used (GitHub Actions, GitLab CI, Jenkins, Bitbucket)?   
> * What stages were included (lint, test, build, deploy)?

### 2. How do you **design and maintain a CI/CD pipeline** for a frontend application?

> How do you handle:
>
>  * environment variables
>  * build optimization
>  * caching dependencies
>  * multiple environments (dev, staging, production)?

### 3. How do you ensure **code quality and stability** in CI/CD?

> * What checks do you add before deployment?
> * How do you prevent broken builds from reaching production?

### 4. How does CI/CD integrate with **Agile development workflows**?

> * How do pull requests, code reviews, and CI checks work together?
> * How do you support frequent releases?

### 5. Why is **version control (Git)** essential in CI/CD pipelines?

> * How do branching strategies (Git Flow, trunk-based development) affect CI/CD?

# React Live Codinng

### 1. Todo List
 
> Build a simple **Todo List** using React.
> 
> ### ✅ Requirements
>
> * Display an input field and an **Add** button
> * Users can add a todo item
> * Display the list of todos
> * Each todo should have a **Delete** button
> * Do not allow empty todos
> * Mark a todo as completed
> * Persist todos after page refresh
> * Clear all todos

### 2. Fetch Users from API 

> Fetch and display a list of users from an API.
> 
> ### ✅ Requirements
>
> * Fetch users from this endpoint: `https://jsonplaceholder.typicode.com/users`
> * Fetch data when the component mounts
> * Show a **loading indicator**
> * Show an **error message** if the request fails
> * Display user **name** and **email**

### 3. Create a React component that manages an array of values.

> Requirements:
>
> * Use React functional components and hooks
> * Store the values in component state
> * Each input must be a controlled component
> * Updating one input should not affect others
> * Update state immutably
> * Add a button to append a new value
> * Add a button to remove a value by index

# Algorithm

### 1. **70. Climbing Stairs** 
### 2. **121. Best Time to Buy and Sell Stock** 
### 3. **53. Maximum Subarray** 
### 4. **268. Missing Number** 
### 5. **283. Move Zeroes** 
### 6. **26. Remove Duplicates from Sorted Array**
### 7. **88. Merge Sorted Array** 
### 8. **414. Third Maximum Number** 
### 9. **189. Rotate Array**
### 10. **55. Jump Game**
### 11. **11. Container With Most Water** 
### 12. **238. Product of Array Except Self** 
### 13. **198. House Robber**
### 14. **213. House Robber II**
### 15. **153. Find Minimum in Rotated Sorted Array** 
### 16. **33. Search in Rotated Sorted Array**
### 17. **36. Valid Sudoku**
### 18. **56. Merge Intervals**
### 19. **15. 3Sum**
### 20. **54. Spiral Matrix**

# System Design

### 1. **How would you design a scalable, performant dashboard web application?**

> Focus areas interviewers expect:

> * Component architecture
> * State management
> * Data fetching & caching
> * Performance optimization
> * Accessibility and responsiveness

### 2. **How would you design a real-time chat application for the web?**

> Focus areas interviewers expect:
>
> * UI architecture
> * Real-time data handling (WebSockets)
> * Message state & synchronization
> * Performance for large message lists
> * Error handling and offline support


### 3. **How would you design a reusable, accessible, and scalable modal component for a large frontend application?**

> **Focus areas interviewers expect you to cover:**
> 
> * API design (props, controlled vs uncontrolled)
> * Accessibility (focus trap, ARIA roles, keyboard handling)
> * Portal usage (`createPortal`)
> * Styling and theming support
> * Performance and stacking multiple modals
