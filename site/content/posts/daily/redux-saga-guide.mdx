---
title: "Redux-Saga: From Beginner to Advanced (A Practical Guide)"
category: Daily
author: Daniel Nguyen
tags: ['#redux']
date: 2025-11-03
thumbnailText: Redux
---

State management in React applications can quickly become complex‚Äîespecially when handling asynchronous logic like API calls, polling, timeouts, and background tasks. While Redux Thunk is great for simple logic, once your app grows, you‚Äôll want something more structured and testable.

**This is where Redux-Saga shines.**
It allows you to manage async flows using **Generator functions**, making your side effects:

‚úÖ Predictable
‚úÖ Testable
‚úÖ Scalable
‚úÖ Maintainable

In this blog, we‚Äôll learn **Redux-Saga** step-by-step‚Äîfrom beginner concepts to advanced patterns.

---

## üß± **What is Redux-Saga?**

Redux-Saga is a middleware for Redux that uses **ES6 Generators** to handle side effects.
The main idea is to write async code that looks synchronous.

```js
import { call, put, takeEvery } from "redux-saga/effects";
```

Think of sagas as "background workers" that listen to Redux actions and react to them.

---

## üì¶ Installation

```bash
npm install redux-saga
```

### Setup Middleware

```js
import createSagaMiddleware from "redux-saga";
import { configureStore } from "@reduxjs/toolkit";
import rootSaga from "./sagas";

const sagaMiddleware = createSagaMiddleware();

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefault) => getDefault().concat(sagaMiddleware),
});

sagaMiddleware.run(rootSaga);

export default store;
```

---

## üê£ Beginner: Your First Saga

Let‚Äôs say you want to fetch Pok√©mon details.

### Actions

```js
export const fetchPokemonRequest = (name) => ({
  type: "FETCH_POKEMON_REQUEST",
  payload: name,
});
export const fetchPokemonSuccess = (data) => ({
  type: "FETCH_POKEMON_SUCCESS",
  payload: data,
});
export const fetchPokemonFailure = (error) => ({
  type: "FETCH_POKEMON_FAILURE",
  error,
});
```

### Saga

```js
import { call, put, takeEvery } from "redux-saga/effects";
import axios from "axios";

function* fetchPokemonSaga(action) {
  try {
    const response = yield call(
      axios.get,
      `https://pokeapi.co/api/v2/pokemon/${action.payload}`
    );
    yield put(fetchPokemonSuccess(response.data));
  } catch (e) {
    yield put(fetchPokemonFailure(e.message));
  }
}

export default function* pokemonSaga() {
  yield takeEvery("FETCH_POKEMON_REQUEST", fetchPokemonSaga);
}
```

---

## üéõ Understanding Key Effects

| Effect                      | Purpose                      | Example                            |
| --------------------------- | ---------------------------- | ---------------------------------- |
| `call(fn, ...args)`         | Call a function              | `yield call(api.getUser, id)`      |
| `put(action)`               | Dispatch Redux action        | `yield put({ type: "DONE" })`      |
| `take(pattern)`             | Wait for specific action     | `yield take("LOGIN")`              |
| `takeEvery(pattern, saga)`  | Run saga for every action    | `yield takeEvery("FETCH", saga)`   |
| `takeLatest(pattern, saga)` | Only run most recent version | `yield takeLatest("SEARCH", saga)` |
| `delay(ms)`                 | Sleep/pause                  | `yield delay(1000)`                |

---

## üöÄ Intermediate: Auto-Refresh / Polling with Cancel

Imagine you want to **auto refresh data every 10 seconds** while a page is open.

### Saga with `race`, `delay`, and `take`

```js
import { call, put, delay, race, take, takeLatest } from "redux-saga/effects";
import axios from "axios";

function* autoRefreshPokemon(action) {
  try {
    while (true) {
      const response = yield call(
        axios.get,
        `https://pokeapi.co/api/v2/pokemon/${action.payload}`
      );
      yield put(fetchPokemonSuccess(response.data));

      // refresh every 10s
      yield delay(10000);
    }
  } finally {
    console.log("Stopped refreshing");
  }
}

function* watchAutoRefresh() {
  while (true) {
    const action = yield take("START_REFRESH");
    yield race([
      call(autoRefreshPokemon, action),
      take("STOP_REFRESH"), // stop when user leaves page
    ]);
  }
}
```

This pattern ensures:

‚úÖ Continues refreshing
‚úÖ Cancels when user leaves
‚úÖ No memory leaks

---

## üß† Advanced Concepts

### 1. **`race`** ‚Äî Competing Tasks

Useful for timeout logic:

```js
const { response, timeout } = yield race({
  response: call(api.fetchData),
  timeout: delay(5000),
});

if (timeout) yield put(showError("Request Timeout"));
```

---

### 2. **`cancelled()`** ‚Äî Cleanup when Saga Ends

```js
import { cancelled } from "redux-saga/effects";

function* taskSaga() {
  try {
    yield call(longRunningTask);
  } finally {
    if (yield cancelled()) {
      console.log("Saga was cancelled, cleaning up‚Ä¶");
    }
  }
}
```

---

### 3. **`all()` ‚Äî Run Sagas in Parallel**

```js
import { all } from "redux-saga/effects";
import pokemonSaga from "./pokemonSaga";
import userSaga from "./userSaga";

export default function* rootSaga() {
  yield all([pokemonSaga(), userSaga()]);
}
```

---

## ‚úÖ When to Use Redux-Saga

Use Saga if your app needs:

| Need                     | Saga Helps?        |
| ------------------------ | ------------------ |
| Complex async flows      | ‚úÖ Excellent        |
| Websocket / long polling | ‚úÖ Best choice      |
| Cancelable operations    | ‚úÖ Built-in support |
| Easy unit testing        | ‚úÖ Very easy        |

If your app just needs simple API calls ‚Üí use **Redux Thunk** instead.

---

## üèÅ Conclusion

Redux-Saga may feel different at first because of generator functions‚Äîbut once you understand the pattern, it becomes one of the **cleanest** and **most powerful** tools for managing complex async behavior.

You now know:

‚úÖ How to create beginner-level sagas
‚úÖ How to use effects (`call`, `put`, `takeLatest`, etc.)
‚úÖ How to handle polling + cancel flows
‚úÖ How to manage advanced race conditions and cleanup

---
