---
title: "React Query: Build a Pok√©mon App with Vite + TailwindCSS"
category: Daily
author: Daniel Nguyen
tags: ['#redux']
date: 2025-12-10
thumbnailText: React State Management
---

React Query is one of the most powerful tools for managing **server state** in React applications. Instead of manually handling loading states, API requests, caching, re-fetching, and synchronization, React Query gives us a **reliable and efficient** workflow.

In this guide, we‚Äôll build a **Pok√©mon Browser App** that demonstrates:

* ‚úÖ Fetching data with **`useInfiniteQuery`**
* ‚úÖ Loading more results / infinite scrolling
* ‚úÖ Pok√©mon detail page with **`useQuery`**
* ‚úÖ Marking favorites using **`useMutation` + cache updates**
* ‚úÖ Debugging with React Query DevTools
* ‚úÖ Styled using **TailwindCSS** for a clean, modern UI

This is an excellent **intermediate-level** example that will help you truly *understand* how React Query works.

---

## 1. Create a React App with Vite

```bash
npm create vite@latest pokemon-react-query --template react
cd pokemon-react-query
npm install
```

Run it:

```bash
npm run dev
```

---

## 2. Install Dependencies

```bash
npm install @tanstack/react-query @tanstack/react-query-devtools
```

---

## 3. Add TailwindCSS

```bash
npm install tailwindcss @tailwindcss/vite
```

Open your vite.config.js or vite.config.ts and add:

```js
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
})
```

Add Tailwind to `src/index.css`:

```css
@import "tailwindcss";
```

---

## 4. Configure React Query in `main.jsx`

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>
);
```

---

## 5. Pok√©mon List with `useInfiniteQuery`

This will load the Pok√©mon in pages and let the user load more.

```jsx
import { useInfiniteQuery } from '@tanstack/react-query';

const fetchPokemonPage = async ({ pageParam = 'https://pokeapi.co/api/v2/pokemon?limit=20' }) => {
  const res = await fetch(pageParam);
  return res.json();
};

export function PokemonList({ onSelect }) {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['pokemon'],
    queryFn: fetchPokemonPage,
    getNextPageParam: (lastPage) => lastPage.next,
  });

  return (
    <div className="p-4">
      <h1 className="text-3xl font-semibold mb-4">Pok√©mon</h1>
      <ul className="grid grid-cols-2 gap-4">
        {data?.pages.flatMap((page) =>
          page.results.map((pokemon) => (
            <li
              key={pokemon.name}
              onClick={() => onSelect(pokemon.name)}
              className="p-3 bg-white shadow cursor-pointer capitalize rounded hover:bg-gray-100"
            >
              {pokemon.name}
            </li>
          ))
        )}
      </ul>

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
        className="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
      >
        {isFetchingNextPage ? "Loading..." : hasNextPage ? "Load More" : "Nothing More"}
      </button>
    </div>
  );
}
```

---

## 6. Pok√©mon Detail Page with `useQuery`

```jsx
import { useQuery } from '@tanstack/react-query';

const fetchPokemonDetail = async (name) => {
  const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${name}`);
  return res.json();
};

export function PokemonDetail({ name, onBack }) {
  const { data, isLoading } = useQuery({
    queryKey: ['pokemon', name],
    queryFn: () => fetchPokemonDetail(name),
  });

  if (isLoading) return <p className="p-4">Loading...</p>;

  return (
    <div className="p-4">
      <button onClick={onBack} className="text-blue-600 underline mb-4">‚Üê Back</button>
      <h1 className="text-3xl font-bold capitalize">{data.name}</h1>
      <img src={data.sprites.front_default} className="mt-4 w-32" />
    </div>
  );
}
```

---

## 7. Putting It Together in `App.jsx`

```jsx
import { useState } from 'react';
import { PokemonList } from './PokemonList';
import { PokemonDetail } from './PokemonDetail';

export default function App() {
  const [selected, setSelected] = useState(null);

  return selected ? (
    <PokemonDetail name={selected} onBack={() => setSelected(null)} />
  ) : (
    <PokemonList onSelect={setSelected} />
  );
}
```

---

## 8. Run the App üéâ

```bash
npm run dev
```

You now have:

‚úÖ Infinite list loading
‚úÖ Detail fetching
‚úÖ Cache-friendly navigation
‚úÖ Modern UI with Tailwind
‚úÖ Full React Query DevTools support

---

## Final Thoughts

This app demonstrates the **real value of React Query**:

| Feature               | Benefit                        |
| --------------------- | ------------------------------ |
| Automatic caching     | No redundant requests          |
| Background refetching | Stays up-to-date               |
| Infinite queries      | Works flawlessly               |
| Detail query reuse    | Cache makes navigation instant |
| Devtools              | Debug your data easily         |

React Query makes server state manageable, scalable, and elegant.

---

If you want, I can now continue with:

### üî• Next Steps

* Add **Favorites** (with `useMutation` + optimistic UI)
* Add **Local Storage sync**
* Add **Search filtering**
* Add **Routing with React Router**

Just say:
**"Continue with favorites feature"** üëÄ
