---
title: "React Query: The Missing Data Layer for React Applications"
category: Daily
author: Daniel Nguyen
tags: ['#redux']
date: 2025-12-10
thumbnailText: React State Management
---

If you've built React applications that communicate with APIs, you’ve probably managed server state using tools like **useState**, **useEffect**, and sometimes **Redux**. But as your app grows, handling loading states, caching, background refetching, pagination, and error recovery can become complicated.

This is where **React Query** shines.

React Query is a powerful data-fetching and state management library designed specifically for **server state**. It simplifies fetching, caching, synchronizing, and updating data in your UI — without the boilerplate of Redux or manual useEffect calls.

---

## **Why React Query?**

Before React Query, typical data-fetching logic looked something like this:

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

useEffect(() => {
  setLoading(true);
  fetch('/api/users')
    .then(res => res.json())
    .then(setData)
    .catch(setError)
    .finally(() => setLoading(false));
}, []);
```

This approach works — but you'll need to repeat similar logic across components and maintain state manually. It’s also tricky to handle things like:

* Refetching in the background
* Data caching and invalidation
* Real-time updates
* Retrying failed requests

React Query **solves all of this** with a clean, declarative API.

---

## **Key Features**

| Feature                          | Description                                                      |
| -------------------------------- | ---------------------------------------------------------------- |
| **Caching**                      | Automatically caches server data to avoid unnecessary requests   |
| **Background Refetching**        | Refreshes data silently when the app regains focus or reconnects |
| **Smart Updates**                | Only updates the UI when data actually changes                   |
| **Pagination & Infinite Scroll** | Built-in helpers for paginated APIs                              |
| **Auto Retry**                   | Automatically retries failed requests with exponential backoff   |
| **DevTools**                     | Visual debugging tools right in the browser                      |

---

## **Installing React Query**

```bash
npm install @tanstack/react-query
```

Or, with Yarn:

```bash
yarn add @tanstack/react-query
```

Next, wrap your app with the `QueryClientProvider`:

```jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
```

---

## **Fetching Data With `useQuery`**

React Query replaces the manual fetch logic with the **useQuery** hook:

```jsx
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json()),
  });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Something went wrong.</p>;

  return (
    <ul>
      {data.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}
```

No need for `useEffect`, `loading`, or `error` states — React Query manages everything.

---

## **Updating Data With `useMutation`**

When you need to modify server data (POST, PUT, DELETE), use `useMutation`:

```jsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function AddUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (newUser) =>
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser),
      }),
    onSuccess: () => {
      queryClient.invalidateQueries(['users']); // refresh data
    },
  });

  return (
    <button onClick={() => mutation.mutate({ name: 'Alice' })}>
      Add User
    </button>
  );
}
```

React Query automatically refreshes the UI when data changes.

---

## **React Query vs Redux / Zustand / Context API**

| Feature                      | React Query            | Redux / Zustand / Context      |
| ---------------------------- | ---------------------- | ------------------------------ |
| Manages Server State         | ✅                      | ❌ (unless manually handled)    |
| Manages UI/Local State       | ❌                      | ✅                              |
| Caching & Background Refetch | ✅                      | ❌                              |
| Boilerplate                  | Very Low               | Moderate / High                |
| Good For                     | API Calls, Remote Data | UI state, theme, toggles, etc. |

**React Query doesn’t replace Redux** — it solves a different problem.
You should use React Query for **server data**, and use Redux/Zustand/Context for **local UI state**.

---

## **When Should You Use React Query?**

Use it if your app:

✅ Fetches remote data
✅ Displays API results frequently
✅ Needs caching and request deduplication
✅ Requires smooth UIs without loading flicker
✅ Needs to sync with server in real-time

Not necessary for:

❌ Static content
❌ Very small apps with one or two fetch calls

---

## **Conclusion**

React Query makes server state management simpler, predictable, and more powerful. Instead of manually managing loading and error states or writing repetitive boilerplate, React Query lets you focus on building your UI — while it handles data consistency, caching, background refetching, and updates.

If your React app deals with APIs frequently, **React Query is a game changer**.

---
