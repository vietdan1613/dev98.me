---
title: "ðŸ“¦ Redux Toolkit: Performance Optimization â€” Memoized Selectors & Clean UI Rendering"
category: Daily
author: Daniel Nguyen
tags: ['#redux']
date: 2025-11-09
thumbnailText: Redux Toolkit
---

In this lesson, weâ€™ll learn how to:

* Use **memoized selectors** with **Reselect**
* **Avoid unnecessary re-renders**
* Improve performance with **smart component splitting**

These techniques help your app stay **fast, efficient, and scalable**.

---

## ðŸŽ¯ Why Optimize Performance?

Every time a Redux state changes:

* Components that use that state will re-render.
* But sometimes, **components re-render even when they donâ€™t need to.**

This becomes problematic when:

* There are many components on the page
* Data structures are large
* State changes frequently

So, we optimize to:
âœ… Reduce wasted renders
âœ… Improve responsiveness
âœ… Scale the UI smoothly

---

## ðŸ” Memoized Selectors with Reselect

### What is a Selector?

A **selector** is a function that reads data from your Redux store:

```js
const selectPokemon = (state) => state.pokemon.items;
```

But sometimes, we need **derived data**, such as filtered or sorted lists.
If we compute derived data inside components, it re-computes on *every render*, even if data didnâ€™t change.

### âœ… Solution: `reselect`

**Reselect** allows us to **cache** derived values using memoization.

Install:

```bash
npm install reselect
```

Create a selector:

```js
import { createSelector } from "reselect";

const selectPokemon = (state) => state.pokemon.items;

export const selectFilteredPokemon = createSelector(
  [selectPokemon],
  (items) => items.filter((p) => p.name.startsWith("a"))
);
```

### Result:

* If `items` hasnâ€™t changed â†’ cached result is reused
* The UI **does not re-render unnecessarily**

---

## ðŸ§  Avoiding Unnecessary Re-renders

Even with Redux Toolkit, re-renders can happen when:

* The component selects *too much state*
* Parent components re-render and push new props down
* Functions are created inline on every render

### Tips to avoid re-renders:

#### âœ… Select only what the component needs:

```js
const name = useSelector((state) => state.user.name);
```

Instead of:

```js
const user = useSelector((state) => state.user);
```

#### âœ… Wrap handlers in `useCallback`

```js
const handleClick = useCallback(() => {
  dispatch(fetchPokemon());
}, [dispatch]);
```

---

## ðŸ§© Component Splitting (Smart UI Structure)

Another key optimization technique is **splitting components** so only the part that depends on Redux state re-renders.

### Example:

Instead of:

```jsx
function PokemonList() {
  const { items, status } = useSelector((state) => state.pokemon);

  return (
    <div>
      <p>Status: {status}</p>
      <ul>
        {items.map((p) => (
          <li key={p.name}>{p.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

Split into smaller components:

```jsx
function PokemonStatus() {
  const status = useSelector((state) => state.pokemon.status);
  return <p>Status: {status}</p>;
}

function PokemonListItems() {
  const items = useSelector((state) => state.pokemon.items);
  return (
    <ul>
      {items.map((p) => (
        <li key={p.name}>{p.name}</li>
      ))}
    </ul>
  );
}
```

Now:

* When `status` changes â†’ only `PokemonStatus` updates
* When `items` changes â†’ only `PokemonListItems` updates
* UI is more efficient and easier to maintain

---

## ðŸŽ¯ Summary

| Technique                               | Benefit                                        |
| --------------------------------------- | ---------------------------------------------- |
| **Reselect memoized selectors**         | Avoid unnecessary recomputation                |
| **Read minimal state with useSelector** | Reduce component re-renders                    |
| **Component splitting**                 | Update only the parts of UI that need updating |

Performance optimization ensures your app stays smooth and scalable as it grows.

---
