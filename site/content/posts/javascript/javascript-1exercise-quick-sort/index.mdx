---
title: "Quick Sort"
category: JavaScript
author: Daniel Nguyen
tags: ['#JavascriptExercise']
date: 2024-04-13
thumbnail: image.jpg
featured: true
---

In this article, we'll dive into **Quick Sort**, a high-performance, divide-and-conquer sorting algorithm that's widely used in real-world applications and coding interviews.

---

## ðŸš€ What is Quick Sort?

**Quick Sort** is a **divide and conquer** algorithm that picks a **pivot** element from the array and partitions the other elements into two sub-arrays:
- Elements **less than** the pivot
- Elements **greater than or equal to** the pivot

Then, it recursively sorts the sub-arrays and merges them together.

---

## ðŸ§  How Quick Sort Works

Letâ€™s say we want to sort this array:  
`[8, 4, 7, 3, 1, 5, 2]`

### Step-by-step:

1. Choose a **pivot** (e.g., the last element `2`).
2. Partition the array into:
   - Left: elements `< 2` â†’ `[1]`
   - Right: elements `>= 2` â†’ `[8, 4, 7, 3, 5]`
3. Recursively apply quick sort to `[1]` and `[8, 4, 7, 3, 5]`
4. Combine sorted arrays with the pivot:  
   `[1] + [2] + quickSort([8, 4, 7, 3, 5])`

Repeat this process until the whole array is sorted.

---

## ðŸ”¢ Quick Sort Implementation in JavaScript

Here's a clean and readable version using recursion and array methods:

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[arr.length - 1];
  const left = [];
  const right = [];

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

### Example:

```javascript
const unsorted = [8, 4, 7, 3, 1, 5, 2];
const sorted = quickSort(unsorted);

console.log(sorted); // Output: [1, 2, 3, 4, 5, 7, 8]
```

---

## ðŸ“ˆ Time and Space Complexity

| Case         | Time Complexity |
|--------------|-----------------|
| Best Case    | O(n log n)      |
| Average Case | O(n log n)      |
| Worst Case   | O(nÂ²) (if poorly implemented) |

- **Space Complexity**: O(log n) for in-place implementations, O(n) for non-in-place (like the version above).

---

## âœ… Pros and Cons

### âœ… Pros:
- Very fast in practice
- In-place (low memory usage) in optimized versions
- Elegant and simple logic

### âš ï¸ Cons:
- Worst-case time is O(nÂ²) if the pivot is poorly chosen
- Not stable (equal elements may not retain their original order)

---

## ðŸ”§ Bonus: In-Place Quick Sort (Without Extra Arrays)

The version above uses extra space for left and right arrays. Here's an **in-place** version that modifies the original array:

```javascript
function quickSortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    quickSortInPlace(arr, left, pivotIndex - 1);
    quickSortInPlace(arr, pivotIndex + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left;

  for (let j = left; j < right; j++) {
    if (arr[j] < pivot) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
    }
  }

  [arr[i], arr[right]] = [arr[right], arr[i]];
  return i;
}
```

---

## ðŸŽ¯ Final Thoughts

Quick Sort is one of the fastest and most efficient sorting algorithms when implemented correctly. Itâ€™s widely used in the real world, often even under the hood in language libraries like JavaScriptâ€™s `Array.prototype.sort()` (in most modern engines).

Knowing how it worksâ€”and how to implement both recursive and in-place versionsâ€”gives you a powerful tool in your algorithm toolbox.

---

