---
title: "Advanced React APIs: Shared Context"
category: React
author: Daniel Nguyen
tags: ['#AdvancedReactAPIs']
date: 2025-06-14
thumbnail: image.jpg
featured: true
---

**üß† How to Share State Across React Components Using Context and Custom Hooks**

When working with React, managing state between components is a common challenge‚Äîespecially when those components are siblings or deeply nested. While **lifting state up** is often the go-to solution, there are cases where it‚Äôs just not practical. In this post, you‚Äôll learn how to share state between components **without prop drilling**, using **React Context** and **custom hooks**.

---

## üö´ The Problem with Isolated State in Custom Hooks

Let‚Äôs start with a simple custom hook:

```tsx
function useCount() {
	const [count, setCount] = useState(0)
	const increment = () => setCount((c) => c + 1)
	return { count, increment }
}
```

Now imagine you use this hook in two separate components:

```tsx
function DisplayCount() {
	const { count } = useCount()
	return <div>{count}</div>
}

function IncrementCount() {
	const { increment } = useCount()
	return <button onClick={increment}>Increment</button>
}

function App() {
	return (
		<div>
			<DisplayCount />
			<IncrementCount />
		</div>
	)
}
```

Looks good, right? But there's a **bug**: Clicking the increment button doesn‚Äôt update the displayed count. Why?

### ‚ùó Each Call to `useCount()` is a Separate State Instance

Every time you call `useCount()`, a new piece of state is created. So `DisplayCount` and `IncrementCount` are not sharing state at all‚Äîthey're isolated.

---

## ‚úÖ The Solution: React Context + Custom Hook

To share state across components without lifting it manually through props, we can use **React Context**.

Let‚Äôs walk through how to do this properly.

---

## üèóÔ∏è Step 1: Create the Context

```tsx
import { createContext, ReactNode, useContext, useState } from 'react'

type CountContextType = {
	count: number
	increment: () => void
}

const CountContext = createContext<CountContextType | null>(null)
```

We initialize the context with `null` to force consumers to only use it within a proper provider.

---

## üß© Step 2: Create the Provider Component

```tsx
function CountProvider({ children }: { children: ReactNode }) {
	const [count, setCount] = useState(0)
	const increment = () => setCount((c) => c + 1)
	const value = { count, increment }

	return <CountContext.Provider value={value}>{children}</CountContext.Provider>
}
```

This component manages the shared state and passes it through the context to its children.

---

## ü™ù Step 3: Build a Custom Hook to Use the Context

```tsx
function useCount() {
	const context = useContext(CountContext)
	if (!context) {
		throw new Error('useCount must be used within a CountProvider')
	}
	return context
}
```

Using this hook ensures that consuming components have access to the shared state, and we get a useful error if the context is missing.

---

## üß± Step 4: Use the Shared Hook in Your Components

```tsx
function DisplayCount() {
	const { count } = useCount()
	return <div>{count}</div>
}

function IncrementCount() {
	const { increment } = useCount()
	return <button onClick={increment}>Increment</button>
}

function App() {
	return (
		<CountProvider>
			<div>
				<DisplayCount />
				<IncrementCount />
			</div>
		</CountProvider>
	)
}
```

üéâ Now the `IncrementCount` button updates the same `count` that `DisplayCount` is showing!

---

## üß† Why Not Use a Default Context Value?

You might wonder: "Can‚Äôt I just provide a default value to `createContext` and skip the Provider?"

Technically yes‚Äîbut there's a **catch**: You lose reactivity. If the context holds a plain object instead of state, updating it won‚Äôt cause consumers to rerender. That‚Äôs why it‚Äôs best practice to **default the context to `null`** and force usage within a proper provider.

---

## üß≠ Real-World Case: Managing Shared URL Search Params

Let‚Äôs say you're using React Router's `useSearchParams()` to access query params in multiple components.

You might try calling `useSearchParams()` in each component separately, like:

```tsx
const [searchParams, setSearchParams] = useSearchParams()
```

But then you realize: ‚ö†Ô∏è this creates **multiple subscriptions to the URL change event**, and the state is **no longer synchronized** across components.

### ‚úÖ Fix: Use a Context Provider

To solve this, wrap your app in a provider that calls `useSearchParams()` once, and expose the value via context. Then, use a custom `useSearchParams()` hook that accesses that context instead of calling the original hook directly.

---

## üß© Summary

* üß™ Calling custom hooks separately = isolated state.
* üèóÔ∏è Use React Context to share state across components.
* üîÅ Context updates trigger rerenders in consumers.
* üí• Avoid default values unless you‚Äôre sure you won‚Äôt need reactivity.
* ‚úÖ Use a custom hook to access the context and ensure provider presence.

---

## üß™ Compatibility Note

> The example above uses `useContext`. Some experimental React versions introduce a new `use()` hook, but for apps using React ‚â§ 18.2, stick with `useContext`.

---

## üí° Takeaway

React Context is a powerful tool when you need to **implicitly share state across components**. Whether you're building compound components, managing shared URL state, or dealing with components that live in different parts of your tree‚Äî**Context + custom hooks = a scalable, clean solution.**

---
