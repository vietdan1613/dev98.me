---
title: "ğŸ¥ React Testing: Testing custom hook"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-28
thumbnailText: React Testing
---

**ğŸ§ª Testing Custom React Hooks the Right Way**

Custom React hooks are one of the most powerful features of the React ecosystem. They let us encapsulate logic into reusable, composable functionsâ€”but once youâ€™ve built a custom hook, you might ask:

> **â€œHow do I test this thing?â€**

This post walks you through **the most effective way to test custom hooks**, based on one key principle:

> ğŸ§  â€œThe more your tests resemble the way your software is used, the more confidence they can give you.â€ â€” Kent C. Dodds

Letâ€™s explore what that really means when it comes to testing hooks.

---

## ğŸ£ How Are Custom Hooks Actually Used?

Hooks are not called in isolation. Theyâ€™re used **inside components**. Thatâ€™s the only place theyâ€™re allowed to be called! So, if you want to write tests that resemble real usage, then you should test your hook **via a component**.

Instead of trying to test the hook directly, we test a component that uses the hookâ€”and verify its behavior from the outside.

This method:

* âœ… Aligns with how the hook is used in real code
* âœ… Avoids implementation details
* âœ… Gives you confidence in your hookâ€™s behavior

---

## ğŸ§ª Example: Testing a useCounter Hook

Letâ€™s say youâ€™ve extracted the logic from a `<Counter />` component into a `useCounter` custom hook.

Hereâ€™s how you can test it the right way:

```js
import * as React from 'react'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import useCounter from '../use-counter'

function CounterComponent() {
  const { count, increment, decrement } = useCounter()
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  )
}

test('it shows initial count and responds to button clicks', async () => {
  render(<CounterComponent />)

  expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0')

  await userEvent.click(screen.getByText(/increment/i))
  expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1')

  await userEvent.click(screen.getByText(/decrement/i))
  expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0')
})
```

âœ… Youâ€™re not testing `useCounter()` directly
âœ… Youâ€™re testing how it behaves **through the component**
âœ… The user could care less that the logic lives in a hookâ€”thatâ€™s an implementation detail

---

## ğŸ’¯ Extra Credit: More Advanced Patterns

### 1. Fake Component for Isolated Hook Testing

Sometimes, you donâ€™t need any UIâ€”you just want to test how the hook behaves directly. You can create a **minimal fake component** to access the hook:

```js
let result
function TestComponent(props) {
  result = useCounter(props)
  return null
}

render(<TestComponent />)

// Now `result` contains the hook's return values
result.increment()
expect(result.count).toBe(1)
```

This isolates the hook logic but still adheres to React rules of hooks.

ğŸ“š Learn more: [How to Test Custom Hooks](https://kentcdodds.com/blog/how-to-test-custom-react-hooks)

---

### 2. ğŸ›  Extract a `setup()` Function

When you find yourself repeating logic in multiple tests, abstract it into a `setup()` function:

```js
const result = {}

function TestComponent(props) {
  Object.assign(result, useCounter(props))
  return null
}

function setup(props) {
  render(<TestComponent {...props} />)
  return result
}

test('allows customization of the initial count', () => {
  const utils = setup({initialCount: 3})
  expect(utils.count).toBe(3)
})

test('allows customization of the step', () => {
  const utils = setup({step: 2})
  utils.increment()
  expect(utils.count).toBe(2)
})
```

This keeps your tests dry and focused.

> ğŸ§  Remember: use `Object.assign` instead of `let result = ...` to ensure React doesnâ€™t lose the reference when rerendering.

---

### 3. ğŸ§ª Use `renderHook` from React Testing Library

You might be thinking: â€œThereâ€™s got to be a library for this!â€ And yesâ€”React Testing Library provides a `renderHook` function just for this purpose!

```js
import { renderHook, act } from '@testing-library/react'
import useCounter from '../use-counter'

test('supports custom initial count and step', () => {
  const { result } = renderHook(() => useCounter({ initialCount: 5, step: 2 }))

  expect(result.current.count).toBe(5)

  act(() => result.current.increment())
  expect(result.current.count).toBe(7)
})
```

This:

* âœ… Handles rendering and rerendering your hook
* âœ… Lets you call `act()` for state updates
* âœ… Gives you access to the current hook state via `result.current`

> ğŸ“¦ This is built into `@testing-library/react` â€” no need to install `@testing-library/react-hooks` anymore.

---

## ğŸ§¼ Recap: Best Practices for Testing Custom Hooks

| Practice                             | Benefit                                                          |
| ------------------------------------ | ---------------------------------------------------------------- |
| âœ… Use a component                    | Aligns test with real usage                                      |
| ğŸ§ª Test behavior, not implementation | Focus on how the hook behaves through UI or side effects         |
| ğŸ›  Use `setup()` function            | DRYs up tests, especially when testing configuration props       |
| ğŸ§  Use `renderHook()` for simplicity | Great for hooks without UI or that return plain values/functions |

---

## ğŸ¦‰ Reflect and Learn More

Remember: your custom hook is just code used in a component. So your tests should treat it the same way your users (aka components) do!

Want to reinforce what youâ€™ve learned? Fill out this elaboration and feedback form:

ğŸ‘‰ [Testing Custom Hooks â€“ Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=08%3A%20testing%20custom%20hooks&em=)

---

## ğŸ‘‹ Final Thoughts

Testing hooks isnâ€™t hardâ€”it just requires thinking from a **user-first** perspective. Whether that user is a component or another hook, write tests that mirror real usage. Thatâ€™s how you build tests that are **resilient**, **refactor-friendly**, and **meaningful**.

If youâ€™d like a ready-to-use hook testing starter template or want help converting your tests to use `renderHook`, let me knowâ€”Iâ€™d be happy to help you level up your testing skills!