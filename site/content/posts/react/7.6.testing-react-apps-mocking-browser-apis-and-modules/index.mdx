---
title: "React Testing: Mocking Browser APIs and modules"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-26
thumbnail: image.jpg
featured: true
---

**ðŸ§ª Mocking Browser APIs and Modules in React Tests**

In the world of frontend testing, one of the most common challenges developers face is:

> â€œHow do I test code that relies on **Browser APIs** or external **modules**?â€

Letâ€™s be honestâ€”our test environments arenâ€™t *real* browsers. But thanks to tools like **Jest** and **jsdom**, we can simulate them. And when simulation isnâ€™t enough, we can **mock** our way through it. Let's learn how to do that effectively without sacrificing too much confidence in our tests.

---

## ðŸ§  A Word on Mocking

When you mock something, you're replacing **the real thing** (API, module, etc.) with a **fake version** for the sake of testing.

Youâ€™re intentionally â€œpoking a hole in realityâ€ â€” which **reduces confidence** but **improves speed and control**.

Thatâ€™s why mocking is best reserved for:

* ðŸ§ª Unit or integration tests
* ðŸ§± Environments like **Jest** running in **Node.js** (not a browser)
* ðŸ¤¹ APIs that are **hard or impossible** to simulate in tests (like `geolocation`, `canvas`, or media queries)

ðŸ“– Learn more:
ðŸ‘‰ [The Merits of Mocking](https://kentcdodds.com/blog/the-merits-of-mocking)
ðŸ‘‰ [What is a JavaScript mock?](https://kentcdodds.com/blog/but-really-what-is-a-javascript-mock)

---

## ðŸ’¡ Why We Need to Mock Browser APIs

Hereâ€™s the truth:

> âš ï¸ Jest tests run in **Node.js**, not a real browser.

Instead, they use a browser-like simulation library called [jsdom](https://github.com/jsdom/jsdom). jsdom does a great job mimicking the DOMâ€”but itâ€™s not perfect.

For example:

* âŒ `window.navigator.geolocation.getCurrentPosition()` is *not implemented* in jsdom
* âŒ `window.resizeTo()` doesnâ€™t exist
* âŒ `matchMedia` is unimplemented

So what do we do?

> âœ… We **mock** them.

Hereâ€™s an example from testing a `useMedia` hook that relies on `matchMedia` and responds to window resizing.

```js
import matchMediaPolyfill from 'mq-polyfill'

beforeAll(() => {
  matchMediaPolyfill(window)

  window.resizeTo = function resizeTo(width, height) {
    Object.assign(this, {
      innerWidth: width,
      innerHeight: height,
      outerWidth: width,
      outerHeight: height,
    }).dispatchEvent(new this.Event('resize'))
  }
})
```

This lets us simulate media queries and resizingâ€”even in Node.

---

## ðŸ§ª Real Example: Mocking Geolocation

Letâ€™s say you have a `Location` component that calls:

```js
navigator.geolocation.getCurrentPosition(success, error)
```

Since `getCurrentPosition` doesnâ€™t exist in jsdom, we need to mock it in our test:

```js
beforeEach(() => {
  const fakePosition = {
    coords: {
      latitude: 51.1,
      longitude: 45.3,
    },
  }

  window.navigator.geolocation = {
    getCurrentPosition: jest.fn((success) => {
      success(fakePosition)
    }),
  }
})
```

This approach:

* ðŸ§  Replaces the real `getCurrentPosition` with a mock
* âœ… Lets us control when and how the callback is called
* ðŸ’¡ Gives full control over testing success and error cases

---

## ðŸŽ Bonus: When to Use `act()`

React testing sometimes requires wrapping updates in `act()` to make sure state updates are processed before assertions.

```js
import { act } from 'react-dom/test-utils'

await act(async () => {
  // run the mocked getCurrentPosition
})
```

Usually, libraries like React Testing Library wrap `act()` for you. But when mocking asynchronous behavior like `geolocation`, you may need it manually.

ðŸ“š Learn more: [Fix the â€œnot wrapped in act(...)â€ warning](https://kentcdodds.com/blog/fix-the-not-wrapped-in-act-warning)

---

## ðŸŽ­ Mocking Modules with Jest

Sometimes, youâ€™re not mocking a browser APIâ€”youâ€™re mocking a module your code imports.

For example, hereâ€™s a simple math module:

```js
// math.js
export const add = (a, b) => a + b
export const subtract = (a, b) => a - b
```

And in the test:

```js
import { add, subtract } from '../math'

jest.mock('../math')

// `add` and `subtract` are now Jest mock functions
add.mockImplementation(() => 42)

expect(add).toHaveBeenCalledWith(2, 3)
```

If you only want to mock **part** of a module:

```js
jest.mock('../math', () => {
  const actual = jest.requireActual('../math')
  return {
    ...actual,
    subtract: jest.fn(),
  }
})
```

This keeps `add()` as-is, but mocks `subtract()`.

ðŸ“– More on this: [Manual Mocks â€“ Jest Docs](https://jestjs.io/docs/manual-mocks)

---

## ðŸ’¯ Extra Credit Challenges

### 1. âœ… Mock the module instead of the browser API

If youâ€™re using a **custom hook** that relies on a browser API (like `useGeoLocation`), you might choose to **mock the hook** instead of the API.

```js
jest.mock('../hooks/useGeoLocation', () => () => ({
  latitude: 12.34,
  longitude: 56.78,
}))
```

This is especially useful when:

* You're confident in the module's test suite
* The browser API is too complex to mock directly
* You want simpler, focused tests for components using that hook

ðŸ’¡ Bonus tip: You can mock a hook with another hookâ€”just return mock state using `useState()` or `useEffect()` inside.

---

### 2. âŒ Test the â€œunhappy pathâ€

Donâ€™t just test success cases. Always test what happens when **errors occur**.

```js
window.navigator.geolocation.getCurrentPosition = jest.fn((_, errorCallback) => {
  errorCallback({ message: 'Permission denied' })
})

expect(screen.getByRole('alert')).toHaveTextContent(/permission denied/i)
```

Make sure your components fail gracefully, show error messages, and remain accessible.

---

## âœ… Recap: Mocking in React Tests

| Mocking Target       | When to Use                                                           |
| -------------------- | --------------------------------------------------------------------- |
| `window` APIs        | When `jsdom` doesnâ€™t support them (`geolocation`, `matchMedia`, etc.) |
| Custom hooks         | When mocking APIs is too complex or unnecessary                       |
| External modules     | When a module does something side-effecty (like making requests)      |
| Use `act()` manually | When mocking async behavior that affects state                        |

---

## ðŸ§  Final Thoughts

Mocking is a double-edged sword: powerful, but easy to misuse. Keep these principles in mind:

* Mock only whatâ€™s necessary
* Avoid mocking what the user would care about
* Use mocking to simulate environments, not to cheat test coverage

And always remember: **the more realistic your tests, the more confidence they give you.**

---

## ðŸ“‹ Practice & Reflect

Fill out the elaboration and feedback form to lock in what youâ€™ve learned:

ðŸ‘‰ [Mocking Browser APIs â€“ Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=06%3A%20mocking%20Browser%20APIs%20and%20modules&em=)

---
