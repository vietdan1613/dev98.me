---
title: "ğŸ§© Advanced React Patterns: State Initializer"
category: React
author: Daniel Nguyen
tags: ['#ReactPatterns']
date: 2025-07-07
thumbnailText: Advanced React Patterns
---

**ğŸ” The State Initializer Pattern in React: Resetting with Confidence**

<callout-success>
<strong>One-liner:</strong> The <strong>State Initializer</strong> pattern allows you to initializeâ€”and reliably resetâ€”component state to its original value without surprises.
</callout-success>

One of the fundamental building blocks of React is `useState()`. But sometimes, initializing state is only half the storyâ€”you also want a way to **reset** it.

The problem? Without proper care, that reset may not behave how you think it should.

Letâ€™s dig into the *State Initializer* pattern, how to implement it correctly, and where it can go wrong. ğŸ§ 

---

## ğŸ The Basic Hook

Letâ€™s start simple with a `useCounter` hook:

```tsx
function useCounter() {
  const [count, setCount] = useState(0)
  const increment = () => setCount(c => c + 1)

  return { count, increment }
}
```

Nothing special. It just counts. But what if we want to let users set the starting value?

---

## ğŸšï¸ Adding Initial State

We can allow for configuration like this:

```tsx
function useCounter({ initialCount = 0 } = {}) {
  const [count, setCount] = useState(initialCount)
  const increment = () => setCount(c => c + 1)

  return { count, increment }
}
```

Now you can start your counter at `10`, `50`, or any value:

```tsx
const { count } = useCounter({ initialCount: 10 })
```

Great! But now comes the kicker...

---

## ğŸ”„ What About Reset?

We want to let users *reset* the count back to that initial value. That means we need to keep track of the original value:

```tsx
function useCounter({ initialCount = 0 } = {}) {
  const [count, setCount] = useState(initialCount)

  const increment = () => setCount(c => c + 1)
  const reset = () => setCount(initialCount)

  return { count, increment, reset }
}
```

So whatâ€™s wrong with that?

### âš ï¸ The Gotcha

Letâ€™s say a parent component re-renders and **passes a new `initialCount`** value. Your hook will use the *new* value for resetsâ€”not the *original one*. ğŸ˜¬

Thatâ€™s not what most people expect. The term â€œresetâ€ implies going back to the state at the time the component was initializedâ€”not the current value of the prop.

---

## ğŸ§· Locking in Initial State with Refs

The solution? Use a `ref` to capture the initial value onceâ€”and never let it change:

```tsx
function useCounter({ initialCount = 0 } = {}) {
  const initialCountRef = useRef(initialCount)
  const [count, setCount] = useState(initialCountRef.current)

  const increment = () => setCount(c => c + 1)
  const reset = () => setCount(initialCountRef.current)

  return { count, increment, reset }
}
```

ğŸ§  `useRef` stores a value that persists across renders *without* causing re-renders. Itâ€™s perfect for capturing â€œonce-on-mountâ€ values like this.

---

## ğŸ§ª Real Example: useToggle with Reducer

This pattern gets even more important when you manage state with a `reducer`. Hereâ€™s a simplified `useToggle` hook:

```tsx
function toggleReducer(state, action) {
  switch (action.type) {
    case 'toggle': return { ...state, on: !state.on }
    case 'reset': return { ...state, on: action.initialOn }
    default: throw new Error('Unhandled action type')
  }
}
```

And hereâ€™s the hook implementation:

```tsx
function useToggle({ initialOn = false } = {}) {
  const initialOnRef = useRef(initialOn)

  const [state, dispatch] = useReducer(toggleReducer, {
    on: initialOnRef.current,
  })

  const toggle = () => dispatch({ type: 'toggle' })
  const reset = () => dispatch({ type: 'reset', initialOn: initialOnRef.current })

  return { on: state.on, toggle, reset }
}
```

Now no matter how `initialOn` changes later from a parent component, your reset behavior is **locked in** to the original value passed.

---

## ğŸ§ª When It Breaks: Resetting with Changing Initial State

Letâ€™s say we do this:

```tsx
function Parent() {
  const [isDarkMode, setDarkMode] = useState(true)

  return (
    <>
      <button onClick={() => setDarkMode(prev => !prev)}>Toggle Initial</button>
      <Toggle initialOn={isDarkMode} />
    </>
  )
}
```

Now if the user toggles `isDarkMode` and then hits reset in the `Toggle` component...

### âŒ Without `useRef`: Reset will use the *current* `isDarkMode`, not the original.

### âœ… With `useRef`: Reset will go back to the original `isDarkMode` value.

This difference is subtle but can lead to serious bugsâ€”especially when components are reused or toggled conditionally.

---

## âœ… Best Practices for the State Initializer Pattern

| Do                                                | Donâ€™t                                                        |
| ------------------------------------------------- | ------------------------------------------------------------ |
| Use `useRef` to lock in initial state             | Donâ€™t trust current `initialX` values after mount            |
| Combine with `useReducer` for complex state logic | Avoid repeating the same `initialX` logic in multiple places |
| Name your initializer and reset methods clearly   | Donâ€™t rely on `useEffect` to â€œpatchâ€ initialization          |

---

## ğŸ§  When to Use the State Initializer Pattern

Use this pattern whenever your component:

* Accepts an â€œinitialâ€ value
* Has a **reset** button or logic
* Should not be influenced by future prop changes to the initial value

Some examples:

* Form inputs that reset to defaults
* Toggle switches that return to a default mode
* Games or counters that reset to starting values

---

## ğŸ”š Conclusion

The **State Initializer Pattern** is simple but powerful. By using `useRef`, you can avoid subtle bugs and make your components more predictableâ€”especially in dynamic or complex applications.

Reset behavior should feel intuitive. By anchoring to the *original initial value*, you ensure your users (and teammates) always know what to expect.

---

## ğŸ§ª Want a Playground?

Want a CodeSandbox demo of this pattern in action? Just ask and Iâ€™ll hook you up with a live example! ğŸ§‘â€ğŸ”§

---

Happy resetting! ğŸ’¡