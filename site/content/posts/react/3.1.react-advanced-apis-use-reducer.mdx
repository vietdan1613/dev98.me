---
title: "ğŸ¯ Advanced React APIs: Advanced State Management"
category: React
author: Daniel Nguyen
tags: ['#AdvancedReactAPIs']
date: 2025-06-11
thumbnailText: Advanced React APIs
---

**ğŸ§  Mastering `useReducer` in React: A Practical Deep Dive**

Reactâ€™s `useState` hook is perfect for many scenarios â€” itâ€™s simple, concise, and expressive. But as your state grows in complexity, managing it with `useState` can start to feel messy. That's where `useReducer` shines.

This post will walk you through **progressively mastering `useReducer`**â€”starting from simple values like counters, all the way to simulating `this.setState` behavior, and finally using it for real-world applications like a Tic Tac Toe game.

## ğŸ“¦ Why Use `useReducer`?

Reactâ€™s `useReducer` is ideal when:

* You want to **separate state logic** from the component
* Multiple values in your state **change together**
* You want more **predictable and declarative state updates**

Letâ€™s explore `useReducer` step-by-step with increasingly powerful examples.

---

## ğŸ§® Step 1: From `useState` to `useReducer` â€” Basic Usage

Letâ€™s start by replacing `useState` with `useReducer` for something simple: updating an input value.

```tsx
function nameReducer(previousName: string, newName: string) {
  return newName
}

const initialNameValue = 'Joe'

function NameInput() {
  const [name, setName] = useReducer(nameReducer, initialNameValue)

  const handleChange = (e) => setName(e.currentTarget.value)

  return (
    <div>
      <label>
        Name: <input defaultValue={name} onChange={handleChange} />
      </label>
      <div>You typed: {name}</div>
    </div>
  )
}
```

ğŸ‘‰ In this case, `useReducer` behaves just like `useState`. The reducer simply returns the new value passed via `dispatch`.

---

## ğŸ” Step 2: Updating a Counter with a Custom Reducer

Letâ€™s build a counter:

```tsx
const countReducer = (currentCount: number, action: number) =>
  currentCount + action

const initialCount = 0
const step = 1

function Counter() {
  const [count, changeCount] = useReducer(countReducer, initialCount)

  const increment = () => changeCount(step)
  const decrement = () => changeCount(-step)

  return (
    <div>
      <button onClick={decrement}>â€“</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  )
}
```

ğŸ§  **Lesson:** The `action` can be any value â€” number, string, object, or function â€” itâ€™s up to you how to use it inside the reducer.

---

## ğŸ“¦ Step 3: Use State Objects (Simulating `this.setState`)

Now letâ€™s work with **objects** to group state variables together â€” much like class components used to do with `this.setState`.

```tsx
function countReducer(state, newState) {
  return { ...state, ...newState }
}

const initialState = {
  count: 0,
  someOtherState: 'hello',
}

function Counter() {
  const [state, setState] = useReducer(countReducer, initialState)
  const { count } = state
  const step = 1

  const increment = () => setState({ count: count + step })
  const decrement = () => setState({ count: count - step })

  return (
    <div>
      <div>{state.someOtherState}</div>
      <button onClick={decrement}>â€“</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  )
}
```

ğŸ’¡ **Why this matters:** Updating state via object merging makes `useReducer` behave a lot like `this.setState`, giving you flexibility while still keeping logic outside your UI code.

---

## ğŸ”„ Step 4: Support Function Updaters (Advanced `this.setState` Simulation)

Letâ€™s make our reducer handle both **objects** and **functions**, just like `this.setState` could.

```tsx
function countReducer(state, action) {
  const newState = typeof action === 'function' ? action(state) : action
  return { ...state, ...newState }
}
```

Now your component can call `setState` with a function:

```tsx
const increment = () =>
  setState((currentState) => ({ count: currentState.count + step }))
```

âœ… **Benefit:** This allows state updates based on the previous state â€” very useful when updates are asynchronous or based on current values.

---

## ğŸ§± Step 5: Traditional Reducer Pattern

Letâ€™s follow the **conventional reducer pattern** with action types. This is common in Redux and large-scale React apps:

```tsx
function countReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + action.step }
    case 'DECREMENT':
      return { ...state, count: state.count - action.step }
    default:
      return state
  }
}
```

Then in your component:

```tsx
const [state, dispatch] = useReducer(countReducer, { count: 0 })
const step = 1

const increment = () => dispatch({ type: 'INCREMENT', step })
const decrement = () => dispatch({ type: 'DECREMENT', step })
```

ğŸ§˜ **Now your component just dispatches actions** â€” no logic about how state changes is embedded in the UI.

---

## ğŸ® Step 6: Real World â€” `useReducer` in Tic Tac Toe

Letâ€™s go further and use `useReducer` in a game.

Weâ€™ll define our actions like this:

```tsx
type GameAction =
  | { type: 'SELECT_SQUARE'; index: number }
  | { type: 'SELECT_STEP'; step: number }
  | { type: 'RESTART' }
```

And the reducer:

```tsx
function gameReducer(state, action) {
  switch (action.type) {
    case 'SELECT_SQUARE': {
      const { index } = action
      // logic to update the board
      return newState
    }
    case 'SELECT_STEP': {
      return {
        ...state,
        currentStep: action.step,
      }
    }
    case 'RESTART': {
      return getInitialGameState()
    }
    default:
      return state
  }
}
```

Using `useReducer`:

```tsx
const [state, dispatch] = useReducer(gameReducer, null, getInitialGameState)
```

ğŸŒ€ **Lazy initialization**: We pass a third argument to `useReducer` (`getInitialGameState`) to avoid calculating initial state on every render.

---

## ğŸ“š Summary

`useReducer` is an advanced tool that opens up better patterns for managing complex state. Hereâ€™s a quick breakdown of what weâ€™ve learned:

| Pattern                        | Description                      |
| ------------------------------ | -------------------------------- |
| Basic value reducer            | Like `useState`, but abstracted  |
| Object merging like `setState` | Useful for grouped state values  |
| Function updater support       | Handles async-safe updates       |
| Action type pattern            | Scales for larger apps           |
| Real-world use (e.g. game)     | Clean separation of logic and UI |

---

## ğŸ“ Resources to Dive Deeper

* ğŸ“˜ [React Docs: `useReducer`](https://react.dev/reference/react/useReducer)
* âœï¸ [Should I `useState` or `useReducer`?](https://kentcdodds.com/blog/should-i-usestate-or-usereducer)
* ğŸ§© [How to Implement `useState` with `useReducer`](https://kentcdodds.com/blog/how-to-implement-usestate-with-usereducer)

---
