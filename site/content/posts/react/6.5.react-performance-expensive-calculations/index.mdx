---
title: "React Performance: Expensive Calculations"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-15
thumbnail: image.png
featured: true
---

**âš¡ Speeding Up Expensive Calculations in React (with `useMemo`, Web Workers & Suspense)**

Modern React development gives us superpowers: composable state, hooks, and declarative UI. But along with great power comesâ€¦ well, performance pitfalls.

One sneaky performance bottleneck? **Expensive calculations inside your render functions.**

In this post, weâ€™ll explore how to identify these issues and fix them using:

* `useMemo` for memoizing heavy functions
* Web Workers for offloading work from the main thread
* Suspense + async rendering for smoother UX

Letâ€™s walk through these one step at a time. ğŸ§ ğŸ’¡

---

## ğŸ§® The Problem: Re-Calculating Every Render

Consider this example:

```tsx
function Distance({ x, y }) {
	const distance = calculateDistance(x, y)
	return <div>The distance between {x} and {y} is {distance}.</div>
}
```

Even if the `x` and `y` values donâ€™t change, if the parent re-renders or local state changes, `calculateDistance` runs again. For heavy calculations or large data sets, this is a performance killer.

---

## âœ… Solution: Memoization with `useMemo`

React provides the `useMemo` hook to optimize these situations:

```tsx
function Distance({ x, y }) {
	const distance = useMemo(() => calculateDistance(x, y), [x, y])
	return <div>The distance between {x} and {y} is {distance}.</div>
}
```

Now, `calculateDistance` only runs when `x` or `y` changes. Simple and effective.

But donâ€™t overuse `useMemo`â€”it adds complexity. Learn when itâ€™s appropriate here:
ğŸ‘‰ [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)

---

## ğŸ¯ Real-World Example: Filtering Cities

Letâ€™s say you have a dropdown with thousands of cities. To help users search efficiently, you're using a library like `match-sorter`:

```tsx
const results = searchCities(userInput)
```

This function is slow, especially on weaker devices.

---

## ğŸ” Step 1: Measuring Performance with DevTools

Before optimizing, letâ€™s **measure**.

1. Run your app in production mode:

   ```bash
   npm run build
   npm run preview
   ```

2. Open Chrome DevTools â†’ **Performance** tab

3. Click the gear âš™ï¸ and enable CPU throttling: **6x slowdown**

4. Start a performance recording, interact with the combobox, and stop the recording.

Look for the `searchCities` call in the flame graph. Is it getting called every time? Even when the search hasnâ€™t changed?

It probably is. Letâ€™s fix that.

---

## ğŸ§  Step 2: Wrap in `useMemo`

Memoize the result of `searchCities`:

```tsx
const results = useMemo(() => searchCities(input), [input])
```

Now it only runs when the input changes. Rerendering the component alone wonâ€™t trigger the expensive function.

ğŸ’¡ **Verify it:** In the Performance tab, search for `searchCities` in the call tree. If youâ€™ve done it right, it shouldnâ€™t appear during unrelated rerenders.

---

## ğŸ§µ Step 3: Moving to a Web Worker

Even when it only runs once, `searchCities` is still **blocking the main thread**. This freezes the UI on slower devices.

Rather than dumbing down our sorting algorithm, letâ€™s move the work **off the main thread** with a **Web Worker**.

### Why Web Workers?

Web Workers allow you to run JS in the background without blocking UI interactions. Perfect for CPU-intensive tasks.

Weâ€™ll use:

* [`comlink`](https://npm.im/comlink) to simplify messaging between the main thread and worker
* [Vite's built-in worker support](https://vitejs.dev/guide/features.html#web-workers)

---

## ğŸ§‘â€ğŸ’» Step 4: Creating the Worker

Letâ€™s refactor our city search into a worker file.

```tsx
// filter-cities.worker.ts
import { expose } from 'comlink'
import { searchCities } from './search-utils'

const api = {
	filterCities: (query: string) => searchCities(query),
}

expose(api)
```

Now in our app:

```tsx
import { wrap } from 'comlink'
import Worker from './filter-cities.worker?worker'

const worker = new Worker()
const api = wrap<WorkerApi>(worker)

async function handleSearch(query: string) {
	const cities = await api.filterCities(query)
	setResults(cities)
}
```

âœ¨ You now have a performant, non-blocking way to search cities!

---

## ğŸŒ€ Step 5: Render Async Results with `Suspense`

Letâ€™s improve the experience further by using **Reactâ€™s `use` hook** and `Suspense` to handle async rendering.

```tsx
const citiesPromise = useMemo(() => api.filterCities(query), [query])
const cities = use(citiesPromise)

return (
	<Suspense fallback={<div>Loading cities...</div>}>
		<CityList cities={cities} />
	</Suspense>
)
```

Add `useTransition` for smooth state transitions without janky UI:

```tsx
const [isPending, startTransition] = useTransition()

const handleInput = (query: string) => {
	startTransition(() => {
		setQuery(query)
	})
}
```

---

## ğŸ§ª Step 6: Validate the Win ğŸ‰

Repeat your DevTools performance trace:

* Record input changes
* Observe flame graph and UI responsiveness
* Search for `searchCities` or blocking operations

You should see a drastic improvement! ğŸš€

---

## ğŸ§  Summary

| Technique          | Purpose                                 |
| ------------------ | --------------------------------------- |
| `useMemo`          | Avoid recalculating on every render     |
| Web Workers        | Offload expensive work from main thread |
| `comlink`          | Simplify worker communication           |
| `useTransition`    | Keep UI responsive during state updates |
| `Suspense` + `use` | Render async results declaratively      |

---

## ğŸ“š Resources

* ğŸ§  [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)
* ğŸ§µ [Speed Up Your App with Web Workers](https://kentcdodds.com/blog/speed-up-your-app-with-web-workers)
* ğŸ› ï¸ [Vite + Web Workers](https://vitejs.dev/guide/features.html#web-workers)
* ğŸª„ [comlink Docs](https://github.com/GoogleChromeLabs/comlink)
* âš™ï¸ [Chrome DevTools Performance Guide](https://developer.chrome.com/docs/devtools/evaluate-performance/)

---

Performance is a user experience issueâ€”and React gives us the tools to fix it.

Use them wisely. âš¡
