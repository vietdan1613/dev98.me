---
title: "React Hook: Tic Tac Toe"
category: React
author: Daniel Nguyen
tags: ['#ReactHooks']
date: 2025-06-07
thumbnail: image.jpg
featured: true
---

**ðŸŽ® Building Tic Tac Toe in React: Mastering `useState`, `useEffect`, and Game State Persistence**

Want to level up your React skills with a hands-on project? Letâ€™s build a classic **Tic Tac Toe** gameâ€”but with a twist! We'll not only manage the game board and handle turns, but also:

* Use **functional updates** with `useState`
* Calculate **derived state** like the winner or next player
* Persist the game with `localStorage`
* Implement a **time-travel-style history feature** to revisit previous moves

Letâ€™s dive in! ðŸŠâ€â™‚ï¸

---

## ðŸ§  Understanding `useState` Functional Updates

Reactâ€™s `useState` lets you update state either directly or via a callback:

```tsx
const [count, setCount] = useState(0)

// Direct update
setCount(count + 1)

// Functional update
setCount(prevCount => prevCount + 1)
```

### ðŸ”‘ When to Use Functional Updates?

**Rule of Thumb:**
If your new state depends on the **previous value**, always use the function form. It ensures you're working with the most up-to-date stateâ€”especially helpful when updates are batched or asynchronous.

---

## ðŸŽ¯ Project Goal: A React Tic Tac Toe Game

Letâ€™s outline the core concepts you'll implement:

### âœ… Managed State

* **`squares`**: A flat array of 9 elements representing the game board.
  Example:

  ```tsx
  ['X', 'O', 'X', 'X', 'O', 'O', 'X', 'X', 'O']
  ```

### ðŸ§® Derived State

* **`nextValue`**: Calculated based on how many "X"s and "O"s are on the board. (We've provided a `calculateNextValue()` utility for this!)
* **`winner`**: Determined by checking win conditions. (`calculateWinner()` handles this logic.)

**Note:** Derived state is calculated on the flyâ€”you donâ€™t store it in `useState`.

---

## âœï¸ Handling Square Clicks

Youâ€™ll update the `squares` array when a user clicks a squareâ€”but **never mutate state directly**!

âŒ Donâ€™t do:

```tsx
squares[0] = 'X'
```

âœ… Do this instead (using `Array.prototype.with()`):

```tsx
const newSquares = squares.with(index, 'X')
```

This ensures immutability, which is essential for React to detect changes correctly.

---

## ðŸ’¾ Persisting Game State with `localStorage`

Want players to resume the game even after closing the browser tab? Store game state in `localStorage`!

### Step 1: Initialize from Local Storage

```tsx
const [squares, setSquares] = useState(() => {
  const stored = localStorage.getItem('tic-tac-toe:squares')
  return stored ? JSON.parse(stored) : Array(9).fill(null)
})
```

### Step 2: Sync Updates with `useEffect`

```tsx
useEffect(() => {
  localStorage.setItem('tic-tac-toe:squares', JSON.stringify(squares))
}, [squares])
```

Now your app is stateful **and** persistent!

---

## âª Adding Time Travel: Game History

Kids hate losing? ðŸ˜… Letâ€™s let them rewind the game and change their moves.

### ðŸ‘£ How Game History Works

Instead of just tracking the current board state (`squares`), you track a **history of all board states**.

```tsx
const [history, setHistory] = useState([Array(9).fill(null)])
const [currentStep, setCurrentStep] = useState(0)

const currentSquares = history[currentStep]
```

### ðŸ•¹ï¸ Making a Move

When a player makes a move:

1. Slice the history up to the current step (to discard future moves).
2. Create a new board with the move.
3. Push the new board onto the history.
4. Update `currentStep`.

```tsx
setHistory(prev => [...prev.slice(0, currentStep + 1), newSquares])
setCurrentStep(prev => prev + 1)
```

### ðŸ”„ Navigating Moves

Add UI buttons to jump to any past move:

```tsx
<button onClick={() => setCurrentStep(index)}>
  Go to move #{index}
</button>
```

---

## ðŸ§¼ A Word on Testing & `localStorage`

ðŸ§ª Be cautious! If youâ€™re writing automated tests or switching between development and test modes, your `localStorage` values can conflict. Clear the storage between sessions or use unique keys to isolate environments.

---

## ðŸ“š Summary

Hereâ€™s what youâ€™ll master in this exercise:

| Feature                   | Concept                                |
| ------------------------- | -------------------------------------- |
| Game board (`squares`)    | Managed state                          |
| Player turn / winner      | Derived state                          |
| Local game persistence    | `useEffect` + `localStorage`           |
| Undoable move history     | Functional `setState` and immutability |
| Performance & correctness | `useState` callback form               |

This isn't just about building a simple gameâ€”itâ€™s a deep dive into **how React state really works**, and how to structure real-world, user-friendly features.

---

## ðŸ”— Resources

* [React Docs: useState](https://react.dev/reference/react/useState)
* [MDN: localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
* [Blog: useState Lazy Initialization & Functional Updates](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)

---

Happy coding! ðŸ§ ðŸ’¡ Let me know if youâ€™d like a working code template for this.
