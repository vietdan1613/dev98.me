---
title: "ğŸ¥ React Testing: Form testing"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-24
thumbnailText: React Testing
---

**ğŸ§ª Form Testing in React: From Basics to Best Practices**

Forms are the heart of many web applications. Whether it's a **login screen**, a **checkout form**, or a **sign-up page**, your users rely on forms to interact with your app. Thatâ€™s why testing forms is **critical**â€”they must always behave as expected, even as your codebase evolves.

In this post, youâ€™ll learn how to test forms using **React Testing Library**, the right wayâ€”**from the userâ€™s perspective**â€”without relying on brittle implementation details. Along the way, youâ€™ll see how to simplify test maintenance, generate realistic data, and write clean, expressive test code.

---

## ğŸ’¡ The Goal of Form Testing

When a user interacts with a form, they expect to:

1. See fields with appropriate labels.
2. Type in their data.
3. Submit the form.
4. See the app respond correctly.

Your test should reflect that same behaviorâ€”**just like a real user would**.

---

## ğŸ§ª The Scenario: A Login Form

Imagine we have a simple login form that accepts a `username` and `password`, then calls an `onSubmit` callback when submitted.

Letâ€™s write a test for this.

### âœ… Step-by-Step Form Test

```jsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Login from '../login' // assume this is your Login component

test('submits username and password', async () => {
  const handleSubmit = jest.fn()
  render(<Login onSubmit={handleSubmit} />)

  const usernameInput = screen.getByLabelText(/username/i)
  const passwordInput = screen.getByLabelText(/password/i)
  const submitButton = screen.getByRole('button', { name: /submit/i })

  await userEvent.type(usernameInput, 'johndoe')
  await userEvent.type(passwordInput, 's3cret')

  await userEvent.click(submitButton)

  expect(handleSubmit).toHaveBeenCalledWith({
    username: 'johndoe',
    password: 's3cret',
  })
})
```

This test does everything from the user's point of view:

* ğŸ§­ Finds fields using accessible labels
* âŒ¨ï¸ Types text with `userEvent`
* âœ… Submits the form
* ğŸ“¦ Verifies the callback received the correct data

---

## ğŸ’¯ Extra Credit: Make Your Tests Even Better

### 1. âœ… Use a Jest Mock Function

Instead of checking `submittedData` manually, you can use `jest.fn()` and assert it was called correctly:

```js
const handleSubmit = jest.fn()
...
expect(handleSubmit).toHaveBeenCalledWith({ username, password })
```

> ğŸ“˜ Read more about [jest.fn()](https://jestjs.io/docs/mock-functions) and [toHaveBeenCalledWith](https://jestjs.io/docs/expect#tohavebeencalledwitharg1-arg2-)

---

### 2. ğŸ”€ Generate Random Test Data

Hardcoding values like `'chucknorris'` or `'password123'` might make the test look specificâ€”even when they arenâ€™t.

Instead, use a data generator to signal:
**â€œThe specific value doesnâ€™t matter here.â€**

```js
import { faker } from '@faker-js/faker'

const username = faker.internet.userName()
const password = faker.internet.password()
```

This clearly communicates that the values donâ€™t hold any special meaningâ€”theyâ€™re just realistic inputs.

---

### 3. ğŸ§° Create a `buildLoginForm` Helper

Make your tests even cleaner and more reusable by wrapping your data generation in a helper:

```js
function buildLoginForm(overrides = {}) {
  return {
    username: faker.internet.userName(),
    password: faker.internet.password(),
    ...overrides,
  }
}
```

Use it like this:

```js
const { username, password } = buildLoginForm()
```

Or, override a field when needed:

```js
const { username, password } = buildLoginForm({ password: 'abc123' })
```

> This communicates intent: *â€œThis test cares about the specific password, but the username can be anything.â€*

---

### 4. ğŸ§™ Use Test Data Bot

Want a cleaner, more structured way to generate test data?

Check out [`@jackfranklin/test-data-bot`](https://www.npmjs.com/package/@jackfranklin/test-data-bot).

```js
import { build, fake } from '@jackfranklin/test-data-bot'

const buildLoginForm = build('LoginForm', {
  fields: {
    username: fake(f => f.internet.userName()),
    password: fake(f => f.internet.password()),
  },
})
```

Now use it in your tests:

```js
const { username, password } = buildLoginForm()
```

This keeps your tests clean, expressive, and ready for future changes.

---

## âœ… Final Tips

| âœ… Good Practice                       | âŒ Bad Practice                          |
| ------------------------------------- | --------------------------------------- |
| Use `getByLabelText` / `getByRole`    | Use `querySelector`, `firstChild`, etc. |
| Use `userEvent` for realistic actions | Use `fireEvent` (less accurate)         |
| Use `jest.fn()` for form submission   | Manually track state                    |
| Generate test data                    | Hardcode usernames like `'admin'`       |

---

## ğŸ§  Summary

* âœ… Test forms like real users fill them out.
* âœ… Keep tests implementation detail-free and refactor-friendly.
* âœ… Use random test data to signal intent and reduce fragility.
* âœ… Use `jest.fn` and custom data builders for clean, maintainable tests.

---

## ğŸ“‹ Reflect and Practice

Ready to reinforce what youâ€™ve learned? Fill out the feedback form:

ğŸ‘‰ [Form Testing â€“ Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=04%3A%20form%20testing&em=)
