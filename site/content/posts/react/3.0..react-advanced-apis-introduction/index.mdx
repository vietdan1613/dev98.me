---
title: "Advanced React APIs: Introduction"
category: React
author: Daniel Nguyen
tags: ['#AdvancedReactAPIs']
date: 2025-06-10
thumbnail: image.jpg
featured: true
---

**ğŸ”§ Mastering Advanced React APIs: A Practical Guide**

React is well-known for its simplicity and flexibility, but as your application grows, youâ€™ll eventually face scenarios that require more than just `useState` and `useEffect`. Thatâ€™s where **Advanced React APIs** come in.

In this guide, weâ€™ll explore powerful React hooks and APIs that you *might not use daily*, but are *essential tools in your React toolbox*. Youâ€™ll learn not just *what* they doâ€”but *why* and *when* you should use them.

---

## ğŸ“¦ What Weâ€™ll Cover

* `useReducer`
* `use` (formerly `useContext`)
* `createContext`
* `useLayoutEffect`
* `useImperativeHandle`
* `useSyncExternalStore`
* `flushSync`
* `createPortal`
* Complex State & Context Management
* Focus & Layout Computation

---

## ğŸ› Complex State Management with `useReducer`

As components grow more complex, managing state with `useState` can quickly turn messy. Enter `useReducer`.

It helps you:

* Consolidate logic in one place (a reducer function)
* Predictably handle multiple state transitions
* Improve readability and testability

You'll often pair `useReducer` with **custom hooks** to make state logic reusable and composable.

**Example use-case**: A shopping cart with various action types like `ADD_ITEM`, `REMOVE_ITEM`, and `CLEAR_CART`.

---

## ğŸ§  Context the Right Way: `createContext` + `use`

While global state is usually managed by libraries like Redux or Zustand, React's Context API is perfect for passing data deeply without prop drilling.

We'll build a custom `SearchParamsProvider` using:

* `createContext()` to define the data structure
* `use()` (or `useContext`) to consume it
* A custom hook like `useSearchParams()` for safer access with built-in error handling

**Real-world use**: Exposing search query parameters to a blog's component tree.

---

## ğŸŒ€ Portals: Rendering Outside the DOM Tree

Some componentsâ€”like modals, tooltips, or dropdownsâ€”need to break out of the usual DOM hierarchy to avoid CSS issues.

Reactâ€™s `createPortal()` API allows you to render children into a DOM node *outside* the parent componentâ€™s DOM tree.

**Why it's useful**:

* Ensures proper layering (z-index)
* Avoids clipping due to `overflow: hidden`
* Perfect for dynamic positioning (tooltips, modals, dropdowns)

---

## ğŸ“ Layout Computation with `useLayoutEffect`

Thereâ€™s a key difference between `useEffect` and `useLayoutEffect`:

* `useEffect` runs **after** the paint
* `useLayoutEffect` runs **before** the paint

When UI calculations (like positioning a tooltip) need to happen before the browser paints the screen, use `useLayoutEffect` to prevent visual flickering.

---

## ğŸ›  Imperative Handles with `useImperativeHandle`

React encourages a declarative style, but sometimes you need imperative access to child componentsâ€”like exposing `.focus()` or `.scrollIntoView()` methods.

With `useImperativeHandle`, you can customize whatâ€™s exposed when a parent uses `ref` on your component.

**Use-case**: Building a reusable input component that allows the parent to call `focus()` directly.

---

## ğŸ¯ Fine-Grained Focus Control with `flushSync`

React batches state updates to optimize performanceâ€”but what if you need something updated *immediately*?

Thatâ€™s where `flushSync()` comes in. It forces React to synchronously flush pending updates. This is especially important for **focus management** in dynamically rendered UIs.

âš ï¸ **Warning**: Itâ€™s a performance trade-off. Use it sparingly and only when necessary.

---

## ğŸ”„ Syncing with the External World: `useSyncExternalStore`

Sometimes your app needs to stay in sync with *external sources of truth*â€”like browser APIs, localStorage, or external libraries (e.g. Redux without React bindings).

`useSyncExternalStore`:

* Subscribes to external stores
* Works with server-side rendering
* Ensures consistency between client and server

**Example**: Listening to a browser API like `window.matchMedia` to reactively respond to dark mode changes.

---

## ğŸ“š Wrapping Up

Advanced React APIs can seem intimidating, but with the right use-cases in mind, they become powerful allies. Hereâ€™s a quick cheat sheet:

| API                     | Use-case                                          |
| ----------------------- | ------------------------------------------------- |
| `useReducer`            | Complex, multi-action state                       |
| `createContext` + `use` | Share global data like auth or theme              |
| `useLayoutEffect`       | Avoid layout flickers when calculating dimensions |
| `useImperativeHandle`   | Expose methods from a child to a parent           |
| `flushSync`             | Synchronous rendering for things like focus       |
| `createPortal`          | Modals, tooltips, or other UI that floats         |
| `useSyncExternalStore`  | Subscribe to external non-React state             |

---

## ğŸ§  Pro Tip

Create **custom hooks** to encapsulate complex logic like reducer-based state or context consumption. This not only improves reusability, but also enhances error handling and developer experience.

---

Mastering these APIs doesnâ€™t mean youâ€™ll use them every dayâ€”but when you *do* need them, youâ€™ll be glad theyâ€™re in your toolbox.

Happy coding! âš›ï¸

---
