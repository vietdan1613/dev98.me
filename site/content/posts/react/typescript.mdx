---
title: "TypeScript"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-28
thumbnailText: React Fundamentals
---

> **"TypeScript is not making your life terrible. It's just showing you how terrible your life already is."**

## 1. TypeScript catches errors at compile time

**What it means:**
TypeScript checks your code before it runs and blocks invalid usage.

```ts
function greet(user: { name: string }) {
  return user.name.toUpperCase()
}

greet({ age: 25 }) 
// âŒ Error: Property 'name' is missing
```

**Why it matters:**
Without TypeScript, this crashes at runtime.
With TypeScript, it never ships.

---

## 2. `type`, `interface`, `enum`

### `type`

Defines a data shape.

```ts
type User = { id: number; name: string }
```

---

### `interface`

Like `type`, but extendable and mergeable.

```ts
interface User {
  id: number
  name: string
}
```

Use `interface` for public object APIs.

---

### `enum`

Represents a fixed set of named values.

```ts
enum Status {
  Loading,
  Success,
  Error,
}
```

---

## 3. Narrowing types

**What it means:**
Restricting values to specific allowed options.

```ts
type Operator = "+" | "-" | "*" | "/"
```

Now `"%"` is rejected at compile time.

---

## 4. Deriving types

**What it means:**
Creating types automatically from real values.

```ts
const operations = {
  "+": (a: number, b: number) => a + b,
  "-": (a: number, b: number) => a - b,
}

type Operator = keyof typeof operations
```

**Why it matters:**
When you change `operations`, `Operator` updates automatically.

---

## 5. `keyof` and `typeof`

### `typeof`

Gets the type of a runtime value.

```ts
type Ops = typeof operations
```

---

### `keyof`

Extracts keys as a union.

```ts
type Operator = keyof Ops
```

---

## 6. Generics

**What it means:**
Write reusable, type-safe code.

```ts
function identity<T>(value: T): T {
  return value
}
```

TypeScript infers `T` automatically.

---

## 7. Utility types

### `Record<K, T>`

**What it does:**
Enforces exact keys and consistent value types.

```ts
type OperationFn = (a: number, b: number) => number

const operations: Record<Operator, OperationFn> = { ... }
```

Now you canâ€™t miss keys or add wrong ones.

---

### `Partial<T>`

**What it does:**
Makes all fields optional.

```ts
type PartialUser = Partial<User>
```

---

### `Pick<T, K>`

**What it does:**
Selects specific fields.

```ts
type UserName = Pick<User, "name">
```

---

### `Omit<T, K>`

**What it does:**
Removes specific fields.

```ts
type UserWithoutId = Omit<User, "id">
```

---

## 8. `satisfies` operator

**What it does:**
Checks shape without losing inference.

```ts
const operations = {
  "+": (a: number, b: number) => a + b,
  "-": (a: number, b: number) => a - b,
} satisfies Record<Operator, OperationFn>
```

**Why itâ€™s better than `: Record<...>`**

* âœ” Validates structure
* âœ” Preserves exact key types
* âœ” Prevents missing keys

---

## 9. `any` vs `unknown` vs `never`

### `any`

Turns off type safety.

```ts
let v: any = 10
v.foo.bar() // allowed, unsafe
```

---

### `unknown`

Forces validation.

```ts
let v: unknown = "hello"

if (typeof v === "string") {
  v.toUpperCase() // safe
}
```

---

### `never`

Represents impossible values.

```ts
function fail(): never {
  throw new Error("Crash")
}
```

Also used for exhaustive checks.

Hereâ€™s the **concise version**:

## Safe vs Unsafe in TypeScript

**Safe** = TypeScript can guarantee it wonâ€™t crash at runtime.
**Unsafe** = TypeScript has to trust you.

### ðŸš¨ Unsafe

* `any` â†’ disables type checking
* `as SomeType` (casts) â†’ you might lie to the compiler
* Using `unknown` without checks
* `// @ts-ignore`, non-null `!`

```ts
let v: any = 10
v.foo.bar() // allowed, unsafe
```

### âœ… Safe

* `unknown` + runtime checks
* Union types (`"a" | "b"`)
* `keyof typeof`
* `satisfies`
* Exhaustive checks with `never`

```ts
let v: unknown = "hi"

if (typeof v === "string") {
  v.toUpperCase() // safe
}
```
