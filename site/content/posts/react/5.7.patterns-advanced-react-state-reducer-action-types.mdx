---
title: "ğŸ§© Advanced React Patterns: State Reducer"
category: React
author: Daniel Nguyen
tags: ['#ReactPatterns']
date: 2025-07-08
thumbnailText: Advanced React Patterns
---

**ğŸ§  The State Reducer Pattern in React: Giving Control Back to Developers**

<callout-success>
<strong>One-liner:</strong> The <strong>State Reducer Pattern</strong> lets you invert control over internal state management, enabling users of your hook or component to customize how state updates happen.
</callout-success>

As a library author or even just a dev building reusable hooks or components, youâ€™ve probably run into this problem:

> â€œCan we make this component behave *slightly* differently in just this one scenario?â€

You could add a new prop. Then a new branch of logic. Then another. Soon enough, your component becomes a bloated maze of flags and conditionals.

Thereâ€™s a better way.

Enter: the **State Reducer Pattern** â€” a clean and powerful way to hand control back to the consumer of your hook or component.

---

## ğŸ¤” Whatâ€™s the Problem?

Letâ€™s say youâ€™re building a `useToggle` hook. Pretty standard:

```tsx
function toggleReducer(state, action) {
  switch (action.type) {
    case 'toggle':
      return { on: !state.on }
    case 'reset':
      return { on: false }
    default:
      throw new Error(`Unhandled action: ${action.type}`)
  }
}

function useToggle() {
  const [state, dispatch] = useReducer(toggleReducer, { on: false })
  const toggle = () => dispatch({ type: 'toggle' })
  const reset = () => dispatch({ type: 'reset' })

  return { on: state.on, toggle, reset }
}
```

Now, someone wants to prevent toggling after 4 clicks. ğŸ˜… Should you:

* Add a `maxToggleCount` prop?
* Track `clickCount` internally?
* Create a separate `AdvancedToggle`?

Nope. Thatâ€™s where the **State Reducer Pattern** shines.

---

## ğŸ”„ Inversion of Control: The Key Idea

With this pattern, instead of baking every state rule into the hook, you let **users decide how state updates**.

They pass in a custom reducer, and your hook **delegates state changes to it**:

```tsx
function useToggle({ reducer = defaultToggleReducer } = {}) {
  const [state, dispatch] = useReducer(reducer, { on: false })

  const toggle = () => dispatch({ type: 'toggle' })
  const reset = () => dispatch({ type: 'reset' })

  return { on: state.on, toggle, reset }
}
```

Now, the user can implement their own logic:

```tsx
function customToggleReducer(state, action) {
  if (action.type === 'toggle' && state.timesClicked >= 4) {
    return state // ignore the action
  }

  switch (action.type) {
    case 'toggle':
      return { on: !state.on, timesClicked: state.timesClicked + 1 }
    case 'reset':
      return { on: false, timesClicked: 0 }
    default:
      return state
  }
}

const { on, toggle, reset } = useToggle({ reducer: customToggleReducer })
```

âœ… You just inverted control of the state logic without having to clutter your original hook.

---

## ğŸ§° Exporting the Default Reducer

Your hook might have some useful behavior that developers still want, even if theyâ€™re customizing things. Rewriting the entire reducer from scratch just to tweak one behavior? No thanks.

Hereâ€™s how you fix that: **export your default reducer** so users can call it within theirs.

```tsx
export function defaultToggleReducer(state, action) {
  switch (action.type) {
    case 'toggle':
      return { on: !state.on }
    case 'reset':
      return { on: false }
    default:
      return state
  }
}
```

Now consumers can write:

```tsx
function toggleStateReducer(state, action) {
  if (action.type === 'toggle' && state.clicks >= 4) {
    return state
  }

  // Let the default handle the rest
  return defaultToggleReducer(state, action)
}
```

This lets them opt in to *just enough* control, without reimplementing your entire logic.

---

## ğŸ§  Why This Matters

This pattern promotes **composability and flexibility** without sacrificing simplicity in the base implementation.

| Benefits                | How                                                  |
| ----------------------- | ---------------------------------------------------- |
| ğŸ”„ Inversion of control | Consumer manages state transitions                   |
| ğŸ§± Extensibility        | Handle custom actions and constraints                |
| ğŸš« Avoid prop explosion | Donâ€™t add a prop for every possible behavior         |
| â™»ï¸ Reuse default logic  | Consumers can call your reducer for standard actions |

---

## âœ… Best Practices

* **Always provide a default reducer** so your hook can be used without customization.
* **Export the default reducer** so itâ€™s available for consumers needing partial customization.
* **Document your action types** so users know what they can intercept.
* Use `useReducer` instead of `useState` when building advanced hooksâ€”it naturally supports this pattern.

---

## ğŸ§ª Real Example: `downshift`

The popular autocomplete library [`downshift`](https://github.com/downshift-js/downshift) is a poster child of this pattern. It uses the **stateReducer** pattern to give users complete control over how the dropdown behavesâ€”without ever having to fork the library.

---

## ğŸ§ Wrap-Up

The **State Reducer Pattern** gives you the best of both worlds:

* Simplicity for those who need it.
* Customization for those who want it.

As your hookâ€™s usage grows and edge cases pop up, this pattern helps you scale flexibility without growing complexity.

> ğŸ› ï¸ Let your users decide what state changes meanâ€”for them.

---

## ğŸ” Want a Demo?

Need a working CodeSandbox or full example of `useToggle` using this pattern? Let me know and Iâ€™ll share a ready-to-use version. ğŸ§‘â€ğŸ”§

---

Happy reducing! âœ‚ï¸
