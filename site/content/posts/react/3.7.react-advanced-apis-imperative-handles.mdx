---
title: "üéØ Advanced React APIs: Imperative Handles"
category: React
author: Daniel Nguyen
tags: ['#AdvancedReactAPIs']
date: 2025-06-17
thumbnailText: Advanced React APIs
---

**üéØ Imperative Handles in React 19**

In React, we usually build UIs in a **declarative** way. But sometimes, you may want to imperatively interact with a child component‚Äîfor example:

* Focusing an input field
* Scrolling to the bottom of a container
* Triggering animations or modals

To do this, React allows you to **expose methods** from a child component to the parent using a `ref`. This `ref` is created with `useRef` and passed down to the child. Once inside the child, you can attach methods to it.

---

## üß† Basic Idea: Exposing Methods via `ref`

```tsx
type InputAPI = { focusInput: () => void }

function MyInput({
	ref,
	...props
}: React.InputHTMLAttributes<HTMLInputElement> & {
	ref: React.RefObject<InputAPI>
}) {
	const inputRef = useRef<HTMLInputElement>(null)

	ref.current = {
		focusInput: () => inputRef.current?.focus(),
	}

	return <input ref={inputRef} {...props} />
}

function App() {
	const myInputRef = useRef<InputAPI>(null)

	return (
		<div>
			<MyInput ref={myInputRef} placeholder="Enter your name" />
			<button onClick={() => myInputRef.current?.focusInput()}>
				Focus the input
			</button>
		</div>
	)
}
```

‚úÖ **This works**, but has limitations:

* ‚ùå Doesn't support **callback refs**
* ‚ùå Can break under **React's concurrent rendering**
* ‚ùå Not ideal with React features like **Suspense**

---

## ‚úÖ The Better Way: `useImperativeHandle`

React provides a built-in hook‚Äî`useImperativeHandle`‚Äîto **safely** expose imperative methods. In React 19, you can now **access `ref` directly as a prop**, so there's **no need for `forwardRef`**.

```tsx
type InputAPI = { focusInput: () => void }

function MyInput({
	ref,
	...props
}: React.InputHTMLAttributes<HTMLInputElement> & {
	ref: React.RefObject<InputAPI>
}) {
	const inputRef = useRef<HTMLInputElement>(null)

	useImperativeHandle(
		ref,
		() => ({
			focusInput: () => inputRef.current?.focus(),
		}),
		[]
	)

	return <input ref={inputRef} {...props} />
}
```

Notice that we passed an **empty dependency array** to `useImperativeHandle`. That‚Äôs fine‚Äîeven if you're using refs inside‚Äîbecause React refs don‚Äôt change between renders, so they don‚Äôt need to be included in dependencies.

> üìò Learn more: [Why you shouldn't put refs in a dependency array](https://epicreact.dev/why-you-shouldnt-put-refs-in-a-dependency-array)

---

## ‚ö†Ô∏è When to Use This

`useImperativeHandle` is useful for:

* DOM interactions (focus, scroll, play, pause, etc.)
* Custom components exposing **actions** to their parent
* Building **reusable component libraries**

> ‚ö†Ô∏è But keep in mind: **imperative code should be a last resort**. It's harder to test, debug, and reason about. Prefer **declarative** solutions when possible.

üìñ More on that here: [Imperative vs Declarative Programming](https://tylermcginnis.com/imperative-vs-declarative-programming/)

---

## ‚úÖ Summary

* `useImperativeHandle` lets child components expose custom methods to their parent.
* In **React 19**, `ref` can be accessed directly from `props`, so there's no need to use `forwardRef`.
* Prefer **declarative solutions** first‚Äîbut when you need to go imperative, now you can do it cleanly.

