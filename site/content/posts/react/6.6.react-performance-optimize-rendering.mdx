---
title: "âš¡ React Performance: Optimize Rendering"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-16
thumbnailText: React Performance
---

**ğŸ§  Optimize React Rendering Like a Pro**

**Eliminate unnecessary re-renders and make your UI fly!**

React is fastâ€¦ *until it isnâ€™t*. While Reactâ€™s virtual DOM and reconciliation algorithms are designed for efficiency, certain patterns in your app can lead to excessive, unnecessary re-renders that hurt performanceâ€”especially on slower devices.

In this guide, youâ€™ll learn:

* How Reactâ€™s rendering lifecycle works
* What causes unnecessary re-renders
* How to fix them with `memo`, custom comparators, and props restructuring

Letâ€™s dive deep and make your components render smarterâ€”not harder. ğŸš€

---

## ğŸŒ€ The React Rendering Lifecycle

Understanding Reactâ€™s internal phases helps us understand *when* and *why* components re-render:

![React Render Cycle](/imgs/react-render-cycle.png)

### Here's what happens:

1. **Render Phase**
   React creates virtual DOM elements via `React.createElement`.

2. **Reconciliation Phase**
   React compares the new elements with the previous render to detect changes.

3. **Commit Phase**
   React updates the actual DOM (if anything changed).

Updating the DOM is expensive, so React avoids it unless necessary. But **rendering** and **reconciling** can also become bottlenecksâ€”especially when they happen more often than they need to.

---

## ğŸ§¾ Why Do React Components Re-render?

A React component will re-render if:

1. Its **props** change
2. Its **state** changes
3. It **consumes context** and the context value changes
4. Its **parent re-renders**

If a component re-renders but its output hasn't changed, that's an **unnecessary re-render**.

---

## ğŸ›‘ Avoiding Unnecessary Re-renders with `memo`

Letâ€™s take a simple app as an example:

```tsx
function CountButton({ count, onClick }) {
	return <button onClick={onClick}>{count}</button>
}

function NameInput({ name, onNameChange }) {
	return (
		<label>
			Name: <input value={name} onChange={(e) => onNameChange(e.target.value)} />
		</label>
	)
}

function App() {
	const [name, setName] = useState('')
	const [count, setCount] = useState(0)

	return (
		<div>
			<CountButton count={count} onClick={() => setCount(c => c + 1)} />
			<NameInput name={name} onNameChange={setName} />
			{name && <p>{name}'s favorite number is {count}</p>}
		</div>
	)
}
```

### ğŸ” The Problem

Every time you click the button, `NameInput` re-rendersâ€”even though its props havenâ€™t changed! Why?

Because the **`App` component re-renders**, and React has no way of knowing whether child components need to re-render or not.

---

## âœ… The Fix: `React.memo`

```tsx
const NameInput = React.memo(function NameInput({ name, onNameChange }) {
	return (
		<label>
			Name: <input value={name} onChange={(e) => onNameChange(e.target.value)} />
		</label>
	)
})
```

Now, `NameInput` will only re-render if `name` or `onNameChange` changes.

### âš ï¸ Be careful!

Donâ€™t wrap everything in `memo`. It adds complexity and might *not* improve performance if your components are already cheap to render.

---

## ğŸ§ª Experiment: What About `CountButton`?

Try wrapping `CountButton` in `memo`:

```tsx
const CountButton = React.memo(function CountButton({ count, onClick }) {
	return <button onClick={onClick}>{count}</button>
})
```

ğŸ’¥ Surprise: It still re-renders!

Why? Because `onClick` is a **new function instance on every render**:

```tsx
const increment = () => setCount(c => c + 1)
```

So React sees a prop change and re-renders anyway.

---

## ğŸ” Fixing That with `useCallback`

```tsx
const increment = useCallback(() => setCount(c => c + 1), [])
```

Now, `onClick` doesnâ€™t change across rendersâ€”and `memo` works.

---

## âš™ï¸ Custom Comparators with `memo`

Sometimes, even if a **prop object** is a new reference, its *contents* havenâ€™t changed. `memo` doesnâ€™t know that by defaultâ€”it just does shallow comparison.

So you can pass a custom comparator:

```tsx
const Avatar = memo(
	function Avatar({ user }: { user: User }) {
		return <img src={user.avatarUrl} alt={user.name} />
	},
	(prevProps, nextProps) => (
		prevProps.user.avatarUrl === nextProps.user.avatarUrl &&
		prevProps.user.name === nextProps.user.name
	)
)
```

Now the component only re-renders when relevant properties change.

---

## ğŸ§¼ Use Primitives Instead

If possible, restructure props to avoid custom comparators:

```tsx
const Avatar = memo(function Avatar({ avatarUrl, name }) {
	return <img src={avatarUrl} alt={name} />
})
```

Now Reactâ€™s default shallow comparison works perfectlyâ€”no need for a custom function.

---

## ğŸ§ª Real-World Debugging: React Profiler & Chrome DevTools

To see what's really going on under the hood:

1. Use the **React DevTools Profiler**

   * Record a render
   * Look for unnecessary component renders
   * Enable â€œWhy did this render?â€ to view the cause

2. Use **Chrome DevTools Performance Tab**

   * Simulate 6x CPU throttling
   * Record and analyze a flame graph
   * Find slow re-render paths

ğŸ”¬ Optimization is only useful if it fixes a real bottleneck.

---

## ğŸ§  Summary

| Optimization      | Use When...                                     |
| ----------------- | ----------------------------------------------- |
| `React.memo`      | Child component receives stable props           |
| `useCallback`     | You pass a function prop to a `memo` component  |
| Custom comparator | Props are objects that change by reference only |
| Primitive props   | You want to avoid writing custom comparators    |
| React Profiler    | You want to confirm actual render performance   |

---

## ğŸ›‘ Final Thoughts

Before you reach for `memo`, **fix the slow render first**. Memoization only helps avoid workâ€”if the work is still slow, it wonâ€™t help.

Check out this article for a deeper look:
ğŸ‘‰ [Fix the slow render before you fix the re-render](https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render)

React is powerful, but optimization takes intent. Profile first, measure, then optimize.

---
