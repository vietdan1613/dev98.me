---
title: "React Performance: Code Splitting"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-14
thumbnail: image.jpg
featured: true
---

**üöÄ Code Splitting in React: Make Your App Load Faster Without Sacrificing Features**

Imagine this: You build a stunning dashboard app packed with advanced visualizations using libraries like D3 and Three.js. Your users are excited‚Äîuntil they open your app and the login screen takes forever to load. What happened?

The answer: **You're loading too much JavaScript up front.**

In this guide, you'll learn how to fix that using **code splitting**‚Äîan essential technique for improving load times in modern React apps. You'll explore:

* `React.lazy()` and `<Suspense />`
* On-demand loading with `import()`
* Eager loading via hover or focus
* Transitions and `useSpinDelay` to improve UX

Let‚Äôs dive in. üèä‚Äç‚ôÇÔ∏è

---

## üì¶ What Is Code Splitting?

**Code splitting** is the practice of breaking your JavaScript bundle into smaller chunks that load only when needed. Instead of shipping all features to the user upfront, you load parts of the code **on demand**‚Äîespecially expensive features that aren‚Äôt used immediately.

Think of it like Netflix only streaming the episode you're watching‚Äînot the entire season at once.

---

## üí° The Core Idea: Less Code = Faster Load

Here‚Äôs a simple example of dynamic imports using native JavaScript:

```tsx
import('/some-module.js').then(
  (module) => {
    // Use module exports here
  },
  (error) => {
    // Handle loading error
  }
);
```

React takes this a step further with built-in support for lazy-loading components.

---

## ‚öõÔ∏è React.lazy + Suspense

React‚Äôs `lazy()` function allows you to dynamically import components. You wrap the lazy-loaded component with `<Suspense />` to show a fallback UI while the code loads.

### Example:

```tsx
// SmileyFace.tsx
export default function SmileyFace() {
  return <div>üòÉ</div>;
}

// App.tsx
import { lazy, Suspense } from 'react';

const SmileyFace = lazy(() => import('./SmileyFace'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <SmileyFace />
      </Suspense>
    </div>
  );
}
```

This allows the bundle containing `SmileyFace` to be **excluded from the main bundle**‚Äîonly fetched when needed.

üõ†Ô∏è Try using [Chrome‚Äôs Coverage tool](https://developer.chrome.com/docs/devtools/coverage) to identify which code is unused at initial load.

---

## üó∫Ô∏è Use Case: Lazy Load a Globe Component

Let‚Äôs say your app has a beautiful 3D globe using heavy libraries like `three.js`. It‚Äôs impressive‚Äîbut it shouldn‚Äôt slow down the login screen.

### The Goal:

Only load the globe code **after** the user clicks ‚ÄúShow Globe.‚Äù

### Solution:

```tsx
import { lazy, Suspense, useState } from 'react';

const Globe = lazy(() => import('./Globe'));

function App() {
  const [showGlobe, setShowGlobe] = useState(false);

  return (
    <div>
      <label>
        <input
          type="checkbox"
          onChange={(e) => setShowGlobe(e.target.checked)}
        />
        Show Globe
      </label>

      <Suspense fallback={<div>Loading globe...</div>}>
        {showGlobe && <Globe />}
      </Suspense>
    </div>
  );
}
```

Open the Network tab in DevTools and watch the JavaScript chunk for `Globe` load **on demand** when you click the checkbox.

üß™ Bonus: Throttle the network to "Slow 3G" to simulate real-world loading scenarios.

---

## ‚ö° Eager Load on Hover or Focus

Sometimes, lazy loading introduces delays that hurt UX. What if 99% of users end up clicking ‚ÄúShow Globe‚Äù anyway? Waiting **twice**‚Äîfirst for the app to load, then for the globe‚Äîis annoying.

### Solution:

**Start loading the module in the background** as soon as the user hovers or focuses on the button.

```tsx
let preloadGlobe = () => import('./Globe');

function App() {
  const [showGlobe, setShowGlobe] = useState(false);
  const Globe = lazy(() => preloadGlobe());

  return (
    <div>
      <label
        onPointerOver={preloadGlobe}
        onFocus={preloadGlobe}
      >
        <input
          type="checkbox"
          onChange={(e) => setShowGlobe(e.target.checked)}
        />
        Show Globe
      </label>

      <Suspense fallback={<div>Loading globe...</div>}>
        {showGlobe && <Globe />}
      </Suspense>
    </div>
  );
}
```

Now, the module begins loading **before** the user even clicks, leading to a faster, smoother experience.

üì¶ Pro Tip: Calling `import()` multiple times is fine‚Äîyour bundler will ensure it only loads once.

---

## ‚ú® Transitions: Avoid Flashing the Fallback

React shows the `<Suspense fallback />` immediately‚Äîeven if the lazy component is already loaded. This can lead to an awkward flash of "Loading..." even when the component is ready.

To fix this, you can use `useTransition` to tell React this update is **non-urgent**. This delays the fallback UI and avoids flashing.

```tsx
import { lazy, Suspense, useTransition } from 'react';

const Globe = lazy(() => import('./Globe'));

function App() {
  const [showGlobe, setShowGlobe] = useState(false);
  const [isPending, startTransition] = useTransition();

  return (
    <div>
      <label
        onPointerOver={() => import('./Globe')}
        onFocus={() => import('./Globe')}
      >
        <input
          type="checkbox"
          onChange={(e) => {
            startTransition(() => {
              setShowGlobe(e.target.checked);
            });
          }}
        />
        Show Globe
      </label>

      {isPending && <span>Preparing globe...</span>}

      <Suspense fallback={<div>Loading globe...</div>}>
        {showGlobe && <Globe />}
      </Suspense>
    </div>
  );
}
```

You can also use the [`spin-delay`](https://npm.im/spin-delay) package to delay the fallback from appearing too quickly:

```tsx
import { useSpinDelay } from 'spin-delay';

const showFallback = useSpinDelay(isPending, {
  delay: 300,
  minDuration: 500
});
```

This adds polish and prevents jarring flashes of UI.

---

## üß† Summary: React Code Splitting Techniques

| Technique                       | Purpose                       | When to Use                           |
| ------------------------------- | ----------------------------- | ------------------------------------- |
| `React.lazy()` + `<Suspense />` | Load components on demand     | For large, infrequently used features |
| `import()` on `hover` / `focus` | Preload eagerly               | For features users often trigger      |
| `useTransition`                 | Defer low-priority UI changes | For lazy components to avoid flashing |
| `useSpinDelay`                  | Smooth loading transitions    | When network speed is inconsistent    |

---

## üß™ Test Your Optimization

Use Chrome DevTools:

* **Network tab**: Throttle and watch chunks load.
* **Coverage tab**: Check which JS was actually used.
* **Performance tab**: Profile rendering and JS execution.

---

## üìö Further Reading

* [React Docs: Code Splitting](https://react.dev/learn/code-splitting)
* [Dynamic Imports Explained](https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-the-browser)
* [`useTransition` API Reference](https://react.dev/reference/react/useTransition)
* [`spin-delay`](https://npm.im/spin-delay)

---
