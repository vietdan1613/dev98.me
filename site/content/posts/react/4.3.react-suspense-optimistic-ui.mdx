---
title: "ðŸ§  React Suspense: Optimistic UI"
category: React
author: Daniel Nguyen
tags: ['#ReactSuspense']
date: 2025-06-23
thumbnailText: React Suspense
---

**âš¡ Building Fast and Fluid Experiences with Optimistic UI in React**

When users interact with your UIâ€”clicking buttons, submitting forms, checking off itemsâ€”they 
expect it to respond instantly. But when those actions involve network requests, even a small 
delay can make the UI feel sluggish.

Thatâ€™s where **Optimistic UI** comes in.

Instead of waiting for the server to respond before updating the UI, we **optimistically** assume 
it will succeed and update the interface immediately. In this post, youâ€™ll learn how to implement 
Optimistic UI with Reactâ€™s powerful tools like `useOptimistic` and `useFormStatus`, plus handle 
multi-step form transitionsâ€”all without hurting user experience.

---

## âœ¨ What is Optimistic UI?

Optimistic UI is based on a simple assumption:

> â€œMost of the time, user actions will succeed.â€

So rather than waiting for confirmation from the server, we immediately update the UI with what 
we **expect** to happen. If something goes wrong, we can always roll it back.

Example: If a user checks off a todo, we mark it complete instantly and send a request in the background.

> âœ… Fast feedback â†’ âš¡ Better UX

You can learn more about this concept at the end of this [talk by Kent C. Dodds](https://www.youtube.com/embed/EzLGleT1yrY).

---

## ðŸ§  Enter `useOptimistic`: Optimism Inside Transitions

React Suspense and `useTransition` are great for deferring UI changes until data is ready. But what 
if we want to **optimistically change the UI** even while it's still suspended?

Thatâ€™s what `useOptimistic` is for. It works like `useState`, but lets you override state 
**during a transition** (such as when submitting a form). This makes it ideal for implementing optimistic UI.

### âœ… Example: Optimistically Toggle a Todo Item

```tsx
function Todo({ todo }: { todo: TodoItem }) {
	const [isComplete, setIsComplete] = useOptimistic(todo.isComplete)

	return (
		<form
			action={async () => {
				setIsComplete(!isComplete) // Update UI optimistically
				await updateTodo(todo.id, !isComplete) // Perform server update
			}}
		>
			<label>
				<input
					type="checkbox"
					checked={isComplete}
					className="todos-checkbox"
				/>
				{todo.text}
			</label>
		</form>
	)
}
```

Notice how `isComplete` updates **instantly**, even before the server responds. Once the action 
completes (success or error), React will re-render using the actual prop value again (`todo.isComplete`).

---

## ðŸ§ª `useFormStatus`: Track Submission State

Sometimes you just want to let users know the form is **submitting**, maybe disable the button or 
change its label. Thatâ€™s where `useFormStatus` shines.

You can think of the `<form>` as a **context provider**, and `useFormStatus` as the **consumer**.

```tsx
function SubmitButton() {
	const formStatus = useFormStatus()

	return (
		<button type="submit" disabled={formStatus.pending}>
			{formStatus.pending ? 'Creating...' : 'Create'}
		</button>
	)
}
```

With this, your button knows when the form is submitting and adjusts accordingly.

ðŸ“š [Learn more about `useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus)

---

## ðŸš€ Optimistic Form Submission in Action

Letâ€™s say youâ€™re building a page to create new pokemons.

The issue: When the user submits the form, there's a noticeable delay before the new 
pokemon appears. This feels slowâ€”even if your API is fast!

Instead, weâ€™ll:

1. Use `createOptimisticPokemon(formData)` to simulate the new pokemon.
2. Show that pokemon immediately while we wait for the real data.
3. Update the real data once it loads.

### Step 1: Update the Optimistic Pokemon

Inside your form action:

```tsx
action={async (formData) => {
	const optimisticPokemon = createOptimisticPokemon(formData)
	setOptimisticPokemon(optimisticPokemon)

	const realPokemon = await updatePokemon(formData)
	setSelectedPokemon(realPokemon.name)
	setOptimisticPokemon(null)
}}
```

Here, `createOptimisticPokemon(formData)` creates a pokemon object instantly (e.g., with `fetchedAt: '...'`). 
We display that in the UI while waiting for `updatePokemon()` to finish.

---

## ðŸŽ¯ Hooking Everything Up

Youâ€™ll need to lift state up to the parent `<App>` component so that `CreateForm` and `PokemonDetails` 
can both access and modify the optimistic pokemon:

```tsx
function App() {
	const [selectedPokemon, setSelectedPokemon] = useState(null)
	const [optimisticPokemon, setOptimisticPokemon] = useState(null)

	return (
		<>
			<CreateForm setOptimisticPokemon={setOptimisticPokemon} setSelectedPokemon={setSelectedPokemon} />
			<PokemonDetails pokemon={optimisticPokemon ?? selectedPokemon} />
		</>
	)
}
```

This lets you render the optimistic pokemon first, and the actual one later when it arrives.

---

## ðŸ§© Bonus: Multi-Step Actions with `useOptimistic`

What if your form action does **multiple steps**?

```tsx
<form
	action={async (formData) => {
		setMessage('Creating pokemon...')
		const pokemon = await updatePokemon(formData)

		setMessage('Saving to database...')
		await savePokemonToDb(pokemon)

		setMessage('Almost done...')
		await notifyFleet(pokemon)
	}}
>
	<SubmitButton />
</form>
```

The problem? You **canâ€™t update local state** like `setMessage` inside a transition... unless you 
use `useOptimistic`.

### âœ… Add an Optimistic Message

```tsx
function CreateForm() {
	const [message, setMessage] = useOptimistic('Create')

	return (
		<form
			action={async (formData) => {
				setMessage('Creating pokemon...')
				const pokemon = await updatePokemon(formData)

				setMessage('Saving to DB...')
				await savePokemonToDb(pokemon)

				setMessage('Almost done...')
				await notifyFleet(pokemon)
			}}
		>
			<SubmitButton message={message} />
		</form>
	)
}

function SubmitButton({ message }: { message: string }) {
	const formStatus = useFormStatus()
	return <button type="submit" disabled={formStatus.pending}>{message}</button>
}
```

Now, your submit button gives **step-by-step feedback** to the userâ€”exactly whatâ€™s happening and when.

---

## ðŸ’¡ Final Thoughts

Optimistic UI is a powerful tool to enhance user experience and build responsive apps that feel **instant**.

**TL;DR:**

* Use `useOptimistic` to **override UI state** during transitions.
* Use `useFormStatus` to **monitor form state** and show submission feedback.
* Combine these to **optimistically render content** and **provide multi-step feedback**.
* Use fallback values like `"..."` for fields not yet fetched.

---
