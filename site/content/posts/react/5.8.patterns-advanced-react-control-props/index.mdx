---
title: "Advanced React Patterns: Control Props"
category: React
author: Daniel Nguyen
tags: ['#ReactPatterns']
date: 2025-07-09
thumbnail: image.jpg
featured: true
---

**ğŸ›ï¸ Control Props in React: Letting Users Take the Wheel**

<callout-success>
<strong>One-liner:</strong> The <strong>Control Props</strong> pattern gives users full control over your componentâ€™s internal stateâ€”just like controlled form elements in React.
</callout-success>

Letâ€™s talk about a powerful pattern that will take your component APIs to the next level of flexibility: **Control Props**.

Imagine this: you're building a reusable component. You want it to work out of the box, but you also want to give developers the option to control its behavior completelyâ€”from the outside.

Sound familiar?

It should. Youâ€™ve already seen this pattern in action a thousand times:

```tsx
<input value={value} onChange={handleChange} />
```

This is a controlled input element. You provide the value, and React calls your `onChange` to â€œsuggestâ€ a new one.

Letâ€™s take that same conceptâ€¦ and apply it to **any reusable component**.

---

## ğŸ§© A Quick Refresher on Controlled Inputs

Controlled inputs are the basis of most React forms:

```tsx
function MyCapitalizedInput() {
  const [capitalizedValue, setCapitalizedValue] = useState("")

  return (
    <input
      value={capitalizedValue}
      onChange={(e) => setCapitalizedValue(e.target.value.toUpperCase())}
    />
  )
}
```

This is a classic example of using control props (`value` and `onChange`). The `input` doesn't manage its own state anymore â€” **you do**.

Why is this so powerful?

* ğŸ”„ You can sync the input value with other components
* ğŸ¯ You can transform user input before storing it
* âš™ï¸ You gain full control over the UI's behavior

---

## ğŸ”¥ Applying This to Custom Components

Letâ€™s say weâ€™ve built a `<Toggle />` component. Itâ€™s a simple on/off switch.

Hereâ€™s the typical version where the component manages its own state:

```tsx
function Toggle() {
  const [on, setOn] = useState(false)
  return <button onClick={() => setOn(!on)}>{on ? "On" : "Off"}</button>
}
```

Nice and simple. But what if someone wants to control that `on` state from the outside?

Now we need to implement **control props**:

```tsx
function Toggle({ on: controlledOn, onChange }) {
  const [internalOn, setInternalOn] = useState(false)

  const isControlled = controlledOn !== undefined
  const on = isControlled ? controlledOn : internalOn

  function toggle() {
    const newState = !on
    if (isControlled) {
      onChange?.(newState)
    } else {
      setInternalOn(newState)
      onChange?.(newState)
    }
  }

  return <button onClick={toggle}>{on ? "On" : "Off"}</button>
}
```

### ğŸ§  Breakdown:

* If `on` is passed in â†’ the component is **controlled**
* If `on` is `undefined` â†’ the component manages state internally
* When toggled â†’

  * In controlled mode: we call `onChange` with the suggested next state
  * In uncontrolled mode: we update internal state and still call `onChange`

This gives users *two options*:

1. Use `<Toggle />` like a normal self-contained component
2. Or pass in `on` and `onChange` to fully manage its state externally

---

## âœ¨ Real-World Example: Synchronizing Inputs

What if we want two components to always reflect the same value?

```tsx
function MyTwoInputs() {
  const [value, setValue] = useState("")

  function handleChange(e) {
    setValue(e.target.value)
  }

  return (
    <>
      <input value={value.toUpperCase()} onChange={handleChange} />
      <input value={value.toLowerCase()} onChange={handleChange} />
    </>
  )
}
```

Using control props here makes it possible to **synchronize behavior** between components. This is especially powerful when building design systems or shared UI libraries.

---

## ğŸ§ª In Practice: Making Toggle Controlled

Back to our `<Toggle />`:

Your exercise is to make it behave like a controlled component. Specifically, you should:

* Accept an `on` prop
* Accept an `onChange` callback
* Internally track state only if `on` is not provided
* When toggled, always call `onChange` with the proposed next value

This will give consumers full flexibility:

* Use the component â€œas-isâ€ without needing to manage state
* Or pass in `on` and `onChange` to take control themselves

---

## ğŸ› ï¸ Real Projects That Use This Pattern

The **Control Props** pattern is used in many popular UI libraries, including:

* [`downshift`](https://github.com/downshift-js/downshift) for autocomplete & dropdowns
* [`@radix-ui/react-select`](https://www.radix-ui.com/primitives/docs/components/select) for customizable select menus

These libraries rely on control props to give users the power to integrate deeply with their own state and data.

---

## âœ… Summary

The **Control Props** pattern:

| âœ… Feature               | ğŸ” Benefit                                             |
| ----------------------- | ------------------------------------------------------ |
| User-controlled state   | Lets devs hook your component into their own app logic |
| Bidirectional sync      | Great for syncing values across components             |
| Declarative flexibility | Makes your API more powerful without adding complexity |

If you're building a reusable component and want to let developers **fully manage or sync state**, then the **Control Props** pattern is exactly what you need.

---

### ğŸ§  Final Thought

Control Props is more than just a fancy name â€” it's about **making components flexible enough to be used in real-world, complex situations** while still being dead simple for the easy cases.

The best APIs do both. ğŸ’ª

---
