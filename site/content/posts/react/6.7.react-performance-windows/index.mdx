---
title: "React Performance: Windowing"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-17
thumbnail: image.png
featured: true
---

**ğŸš€ Boost React Performance with Windowing: A Guide to Virtual Lists**

When building rich, interactive UIs with React, you might eventually hit a serious performance bottleneckâ€”especially if you're rendering large lists, tables, or grids.

Thousands of DOM nodes = slow performance. And even though React is fast, itâ€™s not magic. Thankfully, there's a powerful solution: **windowing**.

In this post, youâ€™ll learn:

* What windowing is and why it's essential
* How it dramatically improves performance
* How to implement it using [`@tanstack/react-virtual`](https://npm.im/@tanstack/react-virtual)

Letâ€™s explore how rendering **less** actually gives your users **more**.

---

## ğŸ§  Why Windowing Matters

React optimizes rendering in three phases:

* **Render Phase** â€“ React creates virtual DOM elements
* **Reconciliation Phase** â€“ React compares previous elements with new ones
* **Commit Phase** â€“ React applies the minimal DOM updates needed

Reactâ€™s speed shines when the DOM updates are small. But what happens when your app tries to render **10,000+ elements**?

Even if each element is simple, React still needs to:

* Run the render logic
* Diff the virtual DOM
* Update the actual DOM

Thatâ€™s where things slow to a crawl.

---

## ğŸ§± The Real-World Problem

Imagine a list with 5,000 rows and 100 columns. Thatâ€™s **500,000 cells**.

You might slice the data like this:

```tsx
const visibleRows = data.slice(0, 500)
```

â€¦but your users want to scroll forever. Removing the slice tanks performance.

They donâ€™t care about reconciliation or commit phases. They just want the app to work. So how do you deliver a seamless experience?

---

## ğŸ’¡ The Solution: Windowing

**Windowing** (also called virtualization) is a technique where you render *only* the items visible in the viewportâ€”and a few extras for smooth scrolling.

Everything else? You skip it entirely until the user scrolls.

### ğŸ¯ Benefits

* Render only what's visible
* Reduce CPU usage and memory footprint
* Faster initial load
* Smooth scrolling and interactionsâ€”even on slow devices

---

## ğŸ›  Enter `@tanstack/react-virtual`

Instead of reinventing the wheel, weâ€™ll use [`@tanstack/react-virtual`](https://npm.im/@tanstack/react-virtual), a battle-tested, flexible library for list virtualization in React.

Letâ€™s refactor a basic list to use it.

### ğŸ¢ Before: Render All Items

```tsx
function MyList({ items }) {
	return (
		<ul>
			{items.map(item => (
				<li key={item.id}>{item.name}</li>
			))}
		</ul>
	)
}
```

This is simple but unscalable for large lists.

---

### âš¡ After: Windowed List with `useVirtualizer`

```tsx
import { useRef } from 'react'
import { useVirtualizer } from '@tanstack/react-virtual'

function MyList({ items }) {
	const parentRef = useRef<HTMLUListElement>(null)

	const rowVirtualizer = useVirtualizer({
		count: items.length,
		getScrollElement: () => parentRef.current,
		estimateSize: () => 30, // height in px per row
	})

	return (
		<ul
			ref={parentRef}
			style={{
				height: 300,
				overflow: 'auto',
				position: 'relative',
			}}
		>
			<li style={{ height: rowVirtualizer.getTotalSize(), position: 'relative' }} />
			{rowVirtualizer.getVirtualItems().map(({ index, key, start, size }) => {
				const item = items[index]
				return (
					<li
						key={key}
						style={{
							position: 'absolute',
							top: 0,
							left: 0,
							width: '100%',
							height: `${size}px`,
							transform: `translateY(${start}px)`,
						}}
					>
						{item.name}
					</li>
				)
			})}
		</ul>
	)
}
```

Now, only visible rows are rendered to the DOM. The rest are skipped until needed.

---

## ğŸ§ª Profiling the Win

With the list virtualization in place, try the following:

1. Open Chrome DevTools.
2. Enable **CPU Throttling** (e.g., 6x slowdown).
3. Record performance before and after windowing.
4. Compare flame graphs and see the difference.

ğŸ‰ Youâ€™ll notice:

* Drastically fewer DOM nodes rendered
* Reduced rendering time
* Smooth scrolling and input

---

## ğŸ¤– Bonus: Integration with Downshift and ComboBoxes

This technique becomes even more powerful when integrated with libraries like [`downshift`](https://github.com/downshift-js/downshift) for combo boxes and typeahead components.

If your filtered result list becomes massive, virtualization can ensure it stays snappy.

---

## ğŸ” A Word on User Experience

You might be tempted to just show the top 500 items and call it a day. But users like infinite scrollâ€”they expect to see *everything*.

**Windowing gives you both**: performance + completeness.

Itâ€™s a win-win. ğŸ¯

---

## ğŸ“¦ Other Virtualization Libraries to Explore

* [`react-window`](https://react-window.now.sh/)
* [`react-virtualized`](https://github.com/bvaughn/react-virtualized)

`@tanstack/react-virtual` is more modern, flexible, and maintained by the creators of TanStack Query.

---

## ğŸ§  Final Thoughts

Rendering thousands of elements in React is a recipe for sluggish UI and frustrated users. With windowing, you:

âœ… Render only what matters
âœ… Improve perceived and actual performance
âœ… Scale UI components confidently

Use `@tanstack/react-virtual`, plug it into your scrollable lists, and give your users that buttery-smooth experienceâ€”even with massive datasets.

Happy optimizing! ğŸ§‘â€ğŸ’»

---
