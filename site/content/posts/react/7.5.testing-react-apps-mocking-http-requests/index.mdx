---
title: "React Testing: Mocking HTTP requests"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-25
thumbnail: image.jpg
featured: true
---

**ğŸ§ª Mocking HTTP Requests in React Tests: The MSW Way**

When you're writing tests for a frontend application, one of the biggest questions is:

> â€œHow do I test components that make HTTP requests?â€

The answer depends on the kind of test you're writing. For **end-to-end (E2E) tests**, itâ€™s ideal to interact with a **real backend** or a **mocked backend** running in the background. But for **unit and integration tests** (especially those run in Jest), mocking HTTP requests is often the most practical approach.

Thatâ€™s where **Mock Service Worker (MSW)** comes inâ€”a powerful library that intercepts network requests in tests and returns mock responses, just like a real server would.

Letâ€™s dive into how and why to use MSW to mock `fetch` in your Jest tests.

---

## ğŸŒ Why Mock HTTP Requests?

When testing user interactions that involve network requests (e.g., form submissions, data fetching), itâ€™s important to:

* âœ… Simulate realistic behavior
* âœ… Keep tests fast and reliable
* âœ… Avoid relying on real APIs or external services

While tools like [Cypress](https://cypress.io) are perfect for full-blown E2E testing, **Jest** is better suited for faster unit and integration tests.

So for our React tests, weâ€™ll **mock network requests using MSW**, ensuring:

* No need for a real server
* No flaky network delays
* High test confidence without losing speed

---

## ğŸ› ï¸ Setting Up MSW in Jest

Imagine a component called `<Fetch />` that requests data from `/greeting` and displays the result.

Here's how we can test it:

```js
// __tests__/fetch.test.js
import * as React from 'react'
import { rest } from 'msw'
import { setupServer } from 'msw/node'
import { render, waitForElementToBeRemoved, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Fetch from '../fetch'

const server = setupServer(
  rest.get('/greeting', (req, res, ctx) => {
    return res(ctx.json({ greeting: 'hello there' }))
  }),
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

test('loads and displays greeting', async () => {
  render(<Fetch url="/greeting" />)

  await userEvent.click(screen.getByText('Load Greeting'))

  await waitForElementToBeRemoved(() => screen.getByText('Loading...'))

  expect(screen.getByRole('heading')).toHaveTextContent('hello there')
  expect(screen.getByRole('button')).toHaveAttribute('disabled')
})
```

âœ… `setupServer` creates an in-memory mock server
âœ… `rest.get()` defines a mock handler for a GET request to `/greeting`
âœ… `server.listen()` activates it for tests
âœ… `waitForElementToBeRemoved` waits for loading state to disappear
âœ… `screen.getByRole` interacts just like a user would

---

## ğŸ˜¬ Testing Failure States

Letâ€™s test what happens when the server returns an error:

```js
test('handles server error', async () => {
  server.use(
    rest.get('/greeting', (req, res, ctx) => {
      return res(ctx.status(500))
    })
  )

  render(<Fetch url="/greeting" />)

  await userEvent.click(screen.getByText('Load Greeting'))

  await waitForElementToBeRemoved(() => screen.getByText('Loading...'))

  expect(screen.getByRole('alert')).toHaveTextContent('Oops, failed to fetch!')
  expect(screen.getByRole('button')).not.toHaveAttribute('disabled')
})
```

This test:

* Overrides the original handler using `server.use`
* Simulates a 500 Internal Server Error
* Checks that the correct error message is displayed

---

## ğŸ’¯ Extra Credit: Make Your Mocking Even Better

### 1. âœ… Reuse Centralized Server Handlers

If you already have a set of reusable MSW handlers (e.g., `test/server-handlers.js`), reuse them:

```js
import { handlers } from '../test/server-handlers'
const server = setupServer(...handlers)
```

This allows:

* Shared mock logic between dev and test
* Offline-friendly development
* Faster prototyping with unfinished APIs

> ğŸ“˜ MSW was originally created for local development mocksâ€”not just testing!

---

### 2. ğŸš¨ Test the Unhappy Path

Donâ€™t forget to test what happens when the user **submits invalid input** or **leaves a field empty**.

Example: leave the password field blank in a login form and verify that the error message appears.

```js
await userEvent.type(screen.getByLabelText(/username/i), 'admin')
// Don't type in the password field

await userEvent.click(screen.getByRole('button', { name: /submit/i }))

expect(screen.getByRole('alert')).toHaveTextContent(/password is required/i)
```

---

### 3. ğŸ§ª Use Inline Snapshots

Manually copying error message strings can be a pain. Instead, use **inline snapshots**:

```js
expect(screen.getByRole('alert').textContent).toMatchInlineSnapshot(
  `"Oops, something went wrong!"`,
)
```

This saves you from hardcoding strings and automatically updates with Jest if the error changes (with your approval).

> ğŸ“š [Snapshot Testing in Jest](https://jestjs.io/docs/snapshot-testing)

---

### 4. ğŸ›  Use One-Off Server Handlers

What if you want to simulate a **server crash** or random failure **only for one test**?

Use **`server.use()`** with a custom response handler:

```js
server.use(
  rest.post(
    'https://auth-provider.example.com/api/login',
    (req, res, ctx) => {
      return res(ctx.status(500), ctx.json({ error: 'Server error!' }))
    }
  )
)
```

This local override avoids:

* Cluttering global handlers
* Breaking other unrelated tests
* Confusing future readers

ğŸ§  Think of it as "test-local mocking" â€” focused and isolated.

---

## ğŸ§¼ Recap: Why Use MSW in React Tests?

| Benefit                     | Explanation                                                         |
| --------------------------- | ------------------------------------------------------------------- |
| ğŸ¯ Intercepts real requests | No need to replace `fetch` or mess with global mocks                |
| ğŸš€ Fast + reliable          | Works offline, no network lag, no port conflicts                    |
| ğŸ§ª Accurate simulation      | Simulates both happy and unhappy paths easily                       |
| ğŸ¤ Reusable                 | Share between development and testing environments                  |
| ğŸ§  Encourages good tests    | Promotes testing what users seeâ€”not internal implementation details |

---

## ğŸ“‹ Reflect and Practice

Want to lock in what youâ€™ve learned about mocking HTTP requests?

âœ… Try using MSW in your own tests
âœ… Write tests for both success and failure cases
âœ… Refactor your mock server into reusable handlers
âœ… Use one-off overrides for focused scenarios

And when youâ€™re ready:

ğŸ‘‰ [Elaboration & Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=05%3A%20mocking%20HTTP%20requests&em=)

---