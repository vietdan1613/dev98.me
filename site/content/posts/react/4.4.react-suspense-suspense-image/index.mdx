---
title: "React Suspense: Suspense img"
category: React
author: Daniel Nguyen
tags: ['#ReactSuspense']
date: 2025-06-24
thumbnail: image.jpg
featured: true
---

**ğŸ–¼ï¸ Smooth & Reliable Image Loading with React Suspense**

React Suspense has revolutionized how we handle asynchronous behavior in UIâ€”especially when fetching data. But did you know you can also **suspend image loading** to create smoother and more predictable visual transitions?

This guide will walk you through:

* Why suspending images is useful
* How to preload images for Suspense
* Handling image load errors gracefully
* Avoiding flickers using suspense `key` props

Letâ€™s start by understanding the **problem**.

---

## ğŸ§¨ The Problem: UI Mismatch with Slow Image Loads

Hereâ€™s a scenario:

1. A user clicks to view a different pokemon.
2. The new **data** loads in \~2 seconds.
3. The new **image** loads in \~10 seconds.
4. The **old image** is still shown while new data is already visible.

This results in a confusing user experience: the **content** changes, but 
the **image** doesnâ€™t update right away.

ğŸ¥ **[Watch the problem](https://www.dropbox.com/scl/fi/k8dnd1u92kd9obf348uq6/bad-img-loading.mp4?rlkey=aois484ivmdjne5n7diorc7xy&raw=1)** â€” the pokemon name and stats change, but the image lags far behind.

---

## âœ… The Goal: A Smooth Image Transition Experience

We want:

* â±ï¸ Pokemon data to show **as soon as it's ready**
* ğŸ“· Pokemon image to show **as soon as itâ€™s loaded**
* âŒ No flickering or showing outdated images

React Suspense gives us the tools to accomplish exactly that.

---

## âš™ï¸ Preloading Images with Promises

React Suspense lets us suspend rendering on any async operationâ€”**not just data fetching**.

So how do we suspend for images?

By preloading them manually:

```tsx
function preloadImage(src: string) {
	return new Promise<string>((resolve, reject) => {
		const img = new Image()
		img.src = src
		img.onload = () => resolve(src)
		img.onerror = reject
	})
}
```

Now you can wrap this in a cache to avoid reloading the same image:

```tsx
const imgCache = new Map<string, Promise<string>>()

function getImgSrc(src: string) {
	if (!imgCache.has(src)) {
		imgCache.set(src, preloadImage(src))
	}
	return imgCache.get(src)!
}
```

Then use Reactâ€™s `use()` hook inside your custom `<Img>` component:

```tsx
function Img({ src, alt }: { src: string; alt: string }) {
	const loadedSrc = use(getImgSrc(src))
	return <img src={loadedSrc} alt={alt} />
}
```

---

## ğŸ§ª Suspending on Images in Practice

By default, React suspends the whole subtree when something inside it suspends. 
So to **suspend only the image**, wrap your `<Img>` in a `Suspense` boundary:

```tsx
<Suspense fallback={<FallbackImage />}>
	<Img src={pokemon.imageUrl} alt={pokemon.name} />
</Suspense>
```

Thatâ€™s greatâ€¦ but what happens when the image **fails** to load?

---

## ğŸ›¡ï¸ Error Boundaries for Broken Images

If an image fails to load (e.g. due to a bad URL or offline connection), React 
will **throw** inside `use()`. If that happens inside `Img`, we want to show a fallback 
imageâ€”not crash the entire pokemon component!

Hereâ€™s how to make an image-specific error boundary:

```tsx
function PokemonImg({ src, alt }: { src: string; alt: string }) {
	return (
		<ErrorBoundary fallback={<img src={src} alt={alt} />}>
			<Suspense fallback={<FallbackImage />}>
				<Img src={src} alt={alt} />
			</Suspense>
		</ErrorBoundary>
	)
}
```

This ensures:

* âœ… Fallback image during load
* âŒ Error fallback if loading fails
* ğŸ§  Clear user feedback instead of a broken UI

---

## âš¡ Advanced: Fixing Image Transitions with `key`

You might still run into a UX problem:

> The UI waits for both data **and** image to load before updating the screen. Thatâ€™s not ideal.

Why? Because Suspense boundaries **inside** a transition (`useTransition`) wonâ€™t show their 
fallback. Theyâ€™ll keep the old UI until everything is ready.

### ğŸ§© The Solution: Add a Unique `key` to the Suspense Boundary

By giving your `Suspense` (or `ErrorBoundary`) a dynamic `key`, you tell React:

> â€œThis is a brand-new boundaryâ€”treat it like an initial render.â€

React will then show the fallback for **just that Suspense boundary**, even while other parts of 
the UI transition smoothly.

```tsx
function PokemonImg({ src, alt }: { src: string; alt: string }) {
	return (
		<ErrorBoundary fallback={<img src={src} alt={alt} />} key={src}>
			<Suspense fallback={<FallbackImage />}>
				<Img src={src} alt={alt} />
			</Suspense>
		</ErrorBoundary>
	)
}
```

âœ… This shows pokemon data ASAP
âœ… Shows image only when it's loaded
âœ… Prevents showing old images with new content

ğŸ¥ [See the improved experience](https://www.dropbox.com/scl/fi/bur28nw0s3tgl7qy39vpm/better-img-loading.mp4?rlkey=y6rq0crkfirf6zd29e2hpb77o&raw=1)

---

## ğŸ§‘â€ğŸ« Summary: Best Practices for Async Images with Suspense

| Feature                 | Technique                                        |
| ----------------------- | ------------------------------------------------ |
| Preload image           | `new Image()` with `onload/onerror`              |
| Suspend on load         | Wrap `preloadImage()` in a cache and use `use()` |
| Fallback UI             | Wrap `<Img>` with `<Suspense fallback={...}>`    |
| Error fallback          | Wrap `Suspense` with `<ErrorBoundary>`           |
| Fix transition behavior | Add `key={src}` to Suspense/ErrorBoundary        |

---

## ğŸš€ Want Even Smoother UX?

Combine this with:

* `useTransition` for smooth UI while transitioning content
* `spin-delay` to delay spinners for brief loads
* `useOptimistic` to show UI even before the async task resolves

---
