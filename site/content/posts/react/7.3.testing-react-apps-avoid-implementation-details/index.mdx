---
title: "React Testing: Avoid implementation details"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-23
thumbnail: image.png
featured: true
---

**ğŸ§ª Avoiding Implementation Details in Your React Tests**

When writing tests for your React components, there's one golden rule that can make your code more robust, flexible, and maintainable:

> âœ… **Donâ€™t test implementation details.**
> âŒ **Test what the user sees and does.**

Letâ€™s break down what that means, why it matters, and how to fix tests that break unnecessarily when you refactor your components.

---

## ğŸ’­ What Are Implementation Details?

**Implementation details** are the internal workings of your code â€” how an outcome is achieved. In contrast, **public behavior** is what the end user sees or interacts with.

Hereâ€™s an example with a simple utility function:

```js
multiply(4, 5) // 20
```

The implementation of `multiply()` could be anything:

```js
const multiply = (a, b) => a * b
```

Or even:

```js
function multiply(a, b) {
  let total = 0
  for (let i = 0; i < b; i++) {
    total += a
  }
  return total
}
```

The point? The user doesnâ€™t care how you got the result â€” just that itâ€™s correct.

Now letâ€™s apply this principle to **React component testing**.

---

## ğŸš¨ A Real Testing Problem

Hereâ€™s a simple `Counter` component:

```jsx
function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return <button onClick={increment}>{count}</button>
}
```

In our test, we might do this:

```js
const { container } = render(<Counter />)
fireEvent.click(container.firstChild)
expect(container.firstChild.textContent).toBe('1')
```

But what if we refactor?

```jsx
function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return (
    <span>
      <button onClick={increment}>{count}</button>
    </span>
  )
}
```

ğŸ’¥ Boom. The test fails â€” even though the component works just fine for the user. Why?
Because we wrote the test based on the componentâ€™s **structure** â€” an **implementation detail**.

---

## âœ… How to Test the Right Way

Letâ€™s fix that using **React Testing Library's user-centric queries**.

```js
import { render, screen, fireEvent } from '@testing-library/react'
import Counter from '../counter'

test('increments the counter', () => {
  render(<Counter />)

  const button = screen.getByRole('button', { name: '0' })
  fireEvent.click(button)

  expect(button).toHaveTextContent('1')
})
```

### Why This Is Better:

* âœ… `screen.getByRole('button', { name: '0' })` matches how users experience the UI
* âœ… Doesnâ€™t rely on specific tag structure or DOM tree
* âœ… Wonâ€™t break if we wrap elements or change HTML tags
* âœ… Easy to refactor your component without rewriting tests

> ğŸ“š Learn more about `screen`:
> [https://testing-library.com/docs/dom-testing-library/api-queries#screen](https://testing-library.com/docs/dom-testing-library/api-queries#screen)

---

## ğŸ’¯ Bonus: Simulate Events Like a Real User

Even calling `fireEvent.click(button)` isnâ€™t *quite* how users interact. When a user clicks a button, they:

* Hover over it
* Focus it
* Mouse down
* Mouse up
* Then click!

Thatâ€™s a lot of interaction, and `fireEvent.click()` only simulates one event.

So letâ€™s go a step further.

### Enter `@testing-library/user-event`

This library simulates **real user behavior** more accurately.

```js
import userEvent from '@testing-library/user-event'

test('increments the counter', async () => {
  render(<Counter />)

  const button = screen.getByRole('button', { name: '0' })
  await userEvent.click(button)

  expect(button).toHaveTextContent('1')
})
```

### Benefits of `userEvent`

* ğŸ¯ Simulates real interaction flow
* ğŸ® Fires all relevant events in the right order
* ğŸ¤ Encourages user-first testing patterns

> ğŸ§ª Explore how it works behind the scenes:
> [`click()` source code](https://github.com/testing-library/user-event/blob/main/src/click.ts)

---

## ğŸ§¼ Recap: Avoid Implementation Details

| âŒ Bad Practice                    | âœ… Good Practice                              |
| --------------------------------- | -------------------------------------------- |
| Query by `container.firstChild`   | Use `screen.getByRole` or `screen.getByText` |
| Assert with `textContent === ...` | Use `toHaveTextContent()`                    |
| Use `fireEvent.click()`           | Use `await userEvent.click()`                |
| Break tests when HTML changes     | Build refactor-friendly, stable tests        |

---

## ğŸ§  Final Thoughts

Tests are only valuable if they continue to give you confidence **after a refactor**.

That means writing tests that focus on what the user **sees** and **does**, not how your component is built.

So next time you write a test, ask yourself:

> â€œWould this still pass if I changed the HTML structure but kept the same behavior?â€

If not, itâ€™s time to ditch the implementation details.

---

## ğŸ“‹ Practice + Reflect

Ready to practice this skill and retain what you learned?
Fill out the elaboration and feedback form:

ğŸ‘‰ [Avoid Implementation Details â€“ Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=03%3A%20Avoid%20implementation%20details&em=)
