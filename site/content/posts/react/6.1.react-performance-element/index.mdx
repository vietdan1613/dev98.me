---
title: "React Performance: Element Optimization"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-11
thumbnail: image.jpg
featured: true
---

**ğŸ¯ React Element Optimization: How to Avoid Unnecessary Renders and Improve Performance**

React is an incredibly powerful UI libraryâ€”but with great power comes the responsibility to keep things **performant**. One of the most common culprits of sluggish React apps? **Unnecessary re-renders**.

This post walks through how React handles re-renders, and more importantly, **how you can optimize your components** using techniques like memoization, JSX reuse, and context. Weâ€™ll build a simple app and use React DevTools to understand what causes a component to re-renderâ€”and how to stop it when we donâ€™t need it.

Letâ€™s dive in!

---

## âš›ï¸ React Elements: The Basics

In React, **elements** are the fundamental building blocks of your UI. JSX gives you a convenient way to define these elements, but under the hood, they're just objects.

Hereâ€™s a quote to keep in mind:

> â€œIf you give React the same element you gave it on the last render, it wonâ€™t bother re-rendering that element.â€
> â€” [Kent C. Dodds](https://twitter.com/kentcdodds/status/1143200604065431552)

Letâ€™s see this in action.

```tsx
function Message({ greeting }) {
  console.log('rendering greeting', greeting)
  return <div>{greeting}</div>
}

function Counter() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        The count is {count}
      </button>
      <Message greeting="Hello!" />
    </div>
  )
}
```

With this setup, clicking the button logs **every time**, even though the `<Message />` component receives the **same props**.

Now look at this slight change:

```tsx
const message = <Message greeting="Hello!" />

function Counter() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        The count is {count}
      </button>
      {message}
    </div>
  )
}
```

Now the `Message` component **only renders once**â€”even when the `count` changes. Why? Because the JSX element is created **once outside** the render function and reused across renders.

ğŸ’¡ **React recognizes itâ€™s the same element and skips the update.**

---

## ğŸ” Reusing Elements to Avoid Renders

Letâ€™s take this further in a real-world scenario.

Imagine your app has a static `<Footer />` that doesnâ€™t depend on state:

```tsx
function Footer() {
  console.log('rendering footer')
  return <footer>Â© 2025 React Workshop</footer>
}

function App() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Click</button>
      <Footer />
    </div>
  )
}
```

Every button click re-renders `<Footer />`, even though it **doesnâ€™t need to**.

### âœ… Fix it by hoisting:

```tsx
const footer = <Footer />

function App() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Click</button>
      {footer}
    </div>
  )
}
```

Boom ğŸ’¥! The footer is no longer re-rendered needlessly.

---

## ğŸ¨ When Props Change: Pass Elements as Props

Now suppose the `Footer` has a **dynamic prop** like a `color`:

```tsx
function Footer({ color }) {
  console.log('rendering footer with color', color)
  return <footer style={{ color }}>Thanks for visiting</footer>
}
```

We can no longer define the JSX statically outside the render function. But we **can** still optimize.

---

## ğŸŒ Optimize With React Context

Letâ€™s use **React Context** to avoid prop drilling and isolate re-renders.

### Step 1: Create a Color Context

```tsx
const ColorContext = React.createContext()
```

### Step 2: Provide color via context

```tsx
function App() {
  const [color, setColor] = useState('black')

  return (
    <ColorContext.Provider value={color}>
      <Main />
    </ColorContext.Provider>
  )
}
```

### Step 3: Consume it in Footer

```tsx
function Footer() {
  const color = useContext(ColorContext)
  console.log('rendering footer with color', color)
  return <footer style={{ color }}>Thanks!</footer>
}
```

Now, Footer doesn't receive **props**, so you can **hoist it again** and React will only re-render it **when context changes**.

---

## ğŸ§  Memoizing Elements with `useMemo`

What if you **must** pass props (like `name`) but still want to optimize?

Reactâ€™s `useMemo()` is your friend:

```tsx
const memoizedFooter = useMemo(() => {
  return <Footer name={name} />
}, [name])
```

Now `<Footer />` is only re-rendered when `name` changesâ€”not on every unrelated state update.

ğŸ’¡ Use `React DevTools Profiler` to confirm re-render behavior.

---

## âš¡ Component-Level Memoization with `React.memo`

React even gives you a **component-level memoizer**: `React.memo`.

```tsx
const Footer = memo(function FooterImpl({ color, name }) {
  console.log('rendering footer')
  return <footer style={{ color }}>Hello, {name}!</footer>
})
```

This acts like a built-in `useMemo()` for components: React skips re-renders unless **props have changed**.

This is a **cleaner and more robust solution** than manually memoizing every element.

> âš ï¸ Be careful: `memo` uses `Object.is` under the hood, so if youâ€™re passing complex objects, you may need to memoize them too.

---

## ğŸ” Final Thoughts

Hereâ€™s a quick summary of **how to optimize React elements** and avoid unnecessary re-renders:

* âœ… **Reuse JSX**: Move static elements outside your component.
* âœ… **Use Context**: Avoid prop drilling and isolate re-renders.
* âœ… **Memoize Elements**: Use `useMemo()` when JSX depends on state.
* âœ… **Memoize Components**: Use `React.memo()` for full component optimization.
* âœ… **Check With DevTools**: Always verify with profiling tools.

React is smartâ€”but itâ€™s not omniscient. A few simple tweaks to how and where you define your elements can yield a **significant performance boost**.

So next time youâ€™re profiling your app and wondering why something is rendering when it shouldnâ€™tâ€”remember this guide ğŸ˜‰

---

ğŸ“š **Further reading:**

* [Optimize React re-renders (Kent C. Dodds)](https://kentcdodds.com/blog/optimize-react-re-renders)
* [React.memo docs](https://react.dev/reference/react/memo)
* [What is JSX?](https://kentcdodds.com/blog/what-is-jsx)

---

Want a live example or need help debugging your own components? Drop a comment or reach out!

Happy optimizing âš›ï¸ğŸ”¥

---
