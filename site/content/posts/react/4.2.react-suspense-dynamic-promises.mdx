---
title: "ğŸ§  React Suspense: Dynamic Promises"
category: React
author: Daniel Nguyen
tags: ['#ReactSuspense']
date: 2025-06-22
thumbnailText: React Suspense
---

**ğŸš€ Mastering Dynamic Promises in React: Caching, Transitions & UX Optimization**

When building modern React applications, fetching data and displaying it efficiently is 
critical for providing a great user experience. But if youâ€™re not careful, data-fetching 
logic can introduce unnecessary network requests, UI flickering, or even infinite loops. 
Letâ€™s walk through how to manage promises dynamically in React, optimize performance with 
caching, and use transition APIs to smooth out the user experience.

---

## ğŸ“¦ The Problem: Re-fetching on Every Render

Letâ€™s start with a simple example:

```tsx
async function fetchUser() {
	const response = await fetch('/api/user')
	const user = await response.json()
	return user
}

function NumberInfo() {
	const [count, setCount] = useState(0)
	const userInfo = use(fetchUser())
	const increment = () => setCount(c => c + 1)

	return (
		<div>
			Hi {userInfo.name}! You have clicked {count} times.
			<button onClick={increment}>Increment again!</button>
		</div>
	)
}
```

Every time you click the button, React re-renders the component, which **calls `fetchUser` 
again**. This triggers a new network request and causes the component to **suspend**, resulting 
in a **janky experience** for users.

---

## âœ… The Fix: Cache the Promise

React can track a single promise throughout the component lifecycle. So, the goal is to cache 
the promise so we donâ€™t trigger unnecessary fetches:

```tsx
let userPromise: Promise<User>

function fetchUser() {
	userPromise = userPromise ?? fetchUserImpl()
	return userPromise
}

async function fetchUserImpl() {
	const response = await fetch('/api/user')
	const user = await response.json()
	return user
}
```

Now, every call to `fetchUser()` will return the same promise unless we explicitly invalidate 
the cache.

---

## ğŸ” Dynamic Caching: Based on Arguments

Letâ€™s say we want to fetch different users by ID. Weâ€™ll need a **cache keyed by ID**:

```tsx
const userPromiseCache = new Map<string, Promise<User>>()

function fetchUser(id: string) {
	let promise = userPromiseCache.get(id)
	if (!promise) {
		promise = fetchUserImpl(id)
		userPromiseCache.set(id, promise)
	}
	return promise
}

async function fetchUserImpl(id: string) {
	const response = await fetch(`/api/user/${id}`)
	const user = await response.json()
	return user
}
```

This approach lets us reuse promises and avoid suspending every time
we change state or refetch the same data.

> ğŸ’¡ Tip: If you need to **reset** the cache (e.g., during development), simply refresh the page.

---

## âœ¨ Improving UX with `useTransition`

Letâ€™s say you allow users to switch between different items (e.g., starpokemons in a UI). 
Switching causes the component to **suspend** and display a fallback UI.

This isnâ€™t ideal, especially if the data loads quicklyâ€”users may still see a flash of a loading spinner.

### `useTransition` to the Rescue!

```tsx
const [isPending, startTransition] = useTransition()

function handlePokemonChange(newPokemon: string) {
	startTransition(() => {
		setSelectedPokemon(newPokemon)
	})
}
```

With `useTransition`, React **keeps the old UI visible** while the new data is loading. 
Meanwhile, the `isPending` flag helps you show a subtle pending indicator (like fading opacity).

```tsx
<div style={{ opacity: isPending ? 0.6 : 1 }}>
	<PokemonDetails pokemon={selectedPokemon} />
</div>
```

This results in a **much smoother experience** compared to instantly switching to a spinner.

---

## ğŸ”„ Avoiding Flashy Spinners with `spin-delay`

Sometimes, loading is so fast (\~50ms) that a spinner appears for a blink, which is visually 
jarring. Instead, you can use [`spin-delay`](https://npm.im/spin-delay) to:

* **Wait before showing a spinner** if the fetch is quick
* **Guarantee the spinner stays visible for a minimum time** if shown

```tsx
import { useSpinDelay } from 'spin-delay'

const [isPending, startTransition] = useTransition()
const showSpinner = useSpinDelay(isPending, {
	delay: 300, // donâ€™t show spinner if it loads faster than 300ms
	minDuration: 350 // keep spinner visible for at least 350ms
})
```

This small tweak can eliminate the "flash of spinner" problem entirelyâ€”making your UI feel faster, 
smoother, and more polished.

---

## ğŸ›  Use Case: Pokemon Viewer with Cache + Transitions

Imagine a UI where users can select starpokemons and view their details. We want:

* ğŸš« No re-fetching the same pokemon
* ğŸ”„ Smooth transitions between pokemon details
* âš¡ No flickering spinner on fast networks

You can achieve this by combining:

* A **cache** using `Map<string, Promise<Pokemon>>`
* `useTransition` to defer state updates
* `useSpinDelay` to smartly show/hide spinners

---

## ğŸ“ Key Takeaways

* Avoid fetching data on every render by **caching promises**.
* Use `useTransition` to **preserve old UI** while new data is loading.
* Enhance loading UX with `useSpinDelay` to **avoid flickers** and provide graceful transitions.
* Combine these techniques for **high-performance, responsive UIs** that feel great to use.

---

## ğŸ“š Further Reading

* ğŸ”— [Caching for Cash (EpicWeb.dev)](https://www.epicweb.dev/talks/caching-for-cash)
* ğŸ”— [Reactâ€™s `useTransition` Documentation](https://react.dev/reference/react/useTransition)
* ğŸ”— [`spin-delay` on npm](https://npm.im/spin-delay)

---
