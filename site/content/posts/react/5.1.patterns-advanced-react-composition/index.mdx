---
title: "Advanced React Patterns: Composition"
category: React
author: Daniel Nguyen
tags: ['#ReactPatterns']
date: 2025-07-02
thumbnail: image.jpg
featured: true
---

**ğŸ§© Composition and Layout Components in React: A Better Way to Share State Without Prop Drilling**

<callout-success>
<strong>TL;DR:</strong> The Composition and Layout Components Pattern helps you avoid prop drilling and makes your components more flexible and reusable.
</callout-success>

## ğŸ¤” What's the Problem with Prop Drilling?

If you've ever built a React app with nested components, you've probably experienced **prop drilling** â€” the tedious process of passing data and functions down through layers of components that donâ€™t even use them.

Before diving into a better pattern, if youâ€™re not familiar with prop drilling, take a moment to read [this blog post](https://kentcdodds.com/blog/prop-drilling). It gives a great overview of why it can be such a pain.

Letâ€™s look at a quick example of prop drilling in action:

```tsx
function App() {
	const [count, setCount] = useState(0)
	const increment = () => setCount(c => c + 1)
	return <Child count={count} increment={increment} />
}

function Child({ count, increment }: { count: number; increment: () => void }) {
	return (
		<div>
			<strong>
				I am a child and I don't actually use count or increment. My child does
				though, so I have to accept those as props and forward them along.
			</strong>
			<GrandChild count={count} onIncrementClick={increment} />
		</div>
	)
}

function GrandChild({
	count,
	onIncrementClick,
}: {
	count: number
	onIncrementClick: () => void
}) {
	return (
		<div>
			<small>I am a grandchild and I just pass things off to a button</small>
			<button onClick={onIncrementClick}>{count}</button>
		</div>
	)
}
```

Notice how `Child` is forced to accept `count` and `increment`, even though it doesnâ€™t use them? This adds coupling and noise, especially as your component tree grows.

Many developers turn to global state solutions or React Context to avoid this, but what if there's a simpler way?

## ğŸ¯ The Composition Pattern: A Cleaner Alternative

Instead of threading state through every layer, what if we just passed **React elements** instead of data?

Hereâ€™s the same functionality rewritten using the **Composition and Layout Components Pattern**:

```tsx
function App() {
	const [count, setCount] = useState(0)
	const increment = () => setCount(c => c + 1)

	return (
		<Child
			grandChild={
				<GrandChild
					button={<button onClick={increment}>{count}</button>}
				/>
			}
		/>
	)
}

function Child({ grandChild }: { grandChild: React.ReactNode }) {
	return (
		<div>
			<strong>
				I am a child and I don't actually use count or increment.
			</strong>
			{grandChild}
		</div>
	)
}

function GrandChild({ button }: { button: React.ReactNode }) {
	return (
		<div>
			<small>I am a grandchild and I just pass things off to a button</small>
			{button}
		</div>
	)
}
```

Now the `App` component manages state and creates the actual UI elements. `Child` and `GrandChild` just arrange and display them. Much cleaner, right?

## ğŸ’¡ Why This Works

By **passing elements instead of data**, you:

* Avoid prop drilling entirely.
* Keep components focused on their actual purpose (e.g., layout or presentation).
* Make components more flexible and reusable.
* Reduce the number of components/files you need to touch when making a change.

Letâ€™s say you want to reuse the `Child` component but change the `GrandChild` layout â€” you donâ€™t need to change how props are passed or restructure your data. You just plug in a different element.

## ğŸ“¦ When to Use This Pattern

This composition technique is particularly helpful when:

* You have deeply nested components with state only needed at the top level.
* You're building reusable layout or container components.
* You want to improve testability and decouple logic from layout.

âš ï¸ Of course, donâ€™t go overboard. You can end up with overly abstract code if you pass every component as a prop. Use this pattern when it adds clarity, not confusion.

## ğŸ§± Layout Components: Reactâ€™s Version of Scoped Slots

If youâ€™re familiar with **Vueâ€™s scoped slots**, this pattern will feel familiar. In React, layout components are simply components that accept elements via props and render them in a specific structure.

The real magic comes from the fact that the parent owns the logic and the layout component owns the structure.

## ğŸ“š Real-World Usage

This pattern is not just theoretical. For example, [kentcdodds.com](https://kentcdodds.com) uses this extensively â€” particularly in the hero sections at the top of each page.

Kent also dives deeper into this idea in his blog post: [One React mistake that's slowing you down](https://epicreact.dev/one-react-mistake-thats-slowing-you-down).

## ğŸ§ª Try It Yourself

In your next project, try replacing some of your prop chains with this composition pattern. Youâ€™ll notice how much more scalable and maintainable your component tree becomes.

For a hands-on exercise, try refactoring a component where youâ€™re passing multiple props down just for a button. Instead, pass the button itself as a React element. Watch how it simplifies everything.

---

### âœ… Takeaways

* Avoid prop drilling by passing components (React elements) instead of data.
* Use layout components to manage structure and leave logic to the parent.
* This pattern makes components easier to reuse and reduces unnecessary dependencies.

Happy composing! ğŸ› ï¸

---
