---
title: "React Performance: Concurrent Rendering"
category: React
author: Daniel Nguyen
tags: ['#ReactPerformance']
date: 2025-07-13
thumbnail: image.jpg
featured: true
---

**ğŸš€ Smooth React UIs with Concurrent Rendering and `useDeferredValue`**

When building modern web apps, we often hit a critical UX bottleneck: **performance during complex renders**. Whether you're filtering long lists or loading content dynamically, sluggish UIs can frustrate users and break immersion.

React 18 introduced **concurrent rendering** to help address this. In this post, weâ€™ll explore what concurrent rendering is, how it works, and how you can use tools like `useDeferredValue` and `memo` to keep your app responsiveâ€”even under load.

---

## ğŸ§  Why Performance Matters: The 16ms Rule

To feel smooth, a web app should update at **60 frames per second**. That gives you around **16 milliseconds per frame** to complete your JavaScript workâ€”including rendering your React components.

If React spends more than that on rendering, the browser canâ€™t paint the next frame in time, leading to jank, input lag, and stuttering animations.

But what if your app legitimately has too much to do in one frame? Enter **concurrent rendering**.

---

## âš™ï¸ What Is Concurrent Rendering?

Concurrent rendering is a new architecture in React 18 that allows React to **pause** a render thatâ€™s taking too long, let the browser catch up, and then **resume** rendering laterâ€”without blocking user interactions.

Imagine React slicing up rendering work into chunks. While rendering, React checks: â€œAm I taking too long?â€ If yes, it yields to the browser and picks up where it left off when thereâ€™s time.

This way, expensive renders like large lists donâ€™t freeze the UI.

To learn more about the theory behind this, check out:

* [React v18 Release Notes](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react)
* [Dan Abramovâ€™s Talk at JSConf Iceland](https://www.youtube.com/watch?v=nLF0n9SACd4)
* [React 18 Keynote](https://youtu.be/FZ0cG47msEk?t=1155)

---

## ğŸª„ But React Canâ€™t Prioritize On Its Ownâ€¦

React is smartâ€”but it doesnâ€™t know which parts of your UI are **high priority**. For example, a user typing in an input should feel snappy, while rendering a giant list of filtered results can wait.

You need to tell React what to deprioritizeâ€”and thatâ€™s where `useDeferredValue` comes in.

---

## ğŸ§ª Introducing `useDeferredValue`

The `useDeferredValue` hook lets you flag certain values as **less urgent**. It tells React: â€œRender this later if something more important is happening.â€

Hereâ€™s an example from the official React docs:

```tsx
function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text); // â† deprioritize this

  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <SlowList text={deferredText} />
    </>
  );
}

const SlowList = memo(function SlowList({ text }) {
  // Simulate slow rendering
  let start = performance.now();
  while (performance.now() - start < 50) {} // â±ï¸ artificial delay
  return <div>{text}</div>;
});
```

### âš ï¸ Important: Use `memo`

React can only skip re-rendering slow components with stale data if theyâ€™re memoized.

If you donâ€™t wrap the component in `React.memo`, React will have to re-render it anywayâ€”even with stale dataâ€”which defeats the purpose of deferring the value.

---

## ğŸ› ï¸ Real-World Example: Slow Card Rendering

Letâ€™s say you're building a card search interface:

* Users type into a search input.
* A grid of `<Card />` components filters and re-renders on each keystroke.
* But rendering each card is slow (maybe it calculates or formats something).

This is the setup for **jank**â€”especially if you filter hundreds of items in real-time.

### Step 1: Memoize the Card Component

First, wrap your slow `Card` component with `memo`:

```tsx
const Card = memo(function Card({ data }) {
  // Simulate heavy render
  let start = performance.now();
  while (performance.now() - start < 30) {}
  return <div>{data.title}</div>;
});
```

This tells React: â€œOnly re-render if props actually change.â€

### Step 2: Defer the Filter Query

If you're filtering the card list using a search query, you can defer that query like this:

```tsx
function CardGrid({ query, data }) {
  const deferredQuery = useDeferredValue(query);

  const filteredData = useMemo(
    () => data.filter(card => card.title.includes(deferredQuery)),
    [deferredQuery, data]
  );

  return (
    <div className="grid">
      {filteredData.map(item => (
        <Card key={item.id} data={item} />
      ))}
    </div>
  );
}
```

Now, the user can type freely into the search input, and React will **pause filtering and card rendering** if the browser needs to remain responsive.

### Result?

ğŸ’¡ **Typing feels instant**, even with expensive components!

---

## ğŸ¯ When to Use `useDeferredValue`

`useDeferredValue` shines when:

* You have user interactions (typing, dragging) and want to keep them smooth
* Youâ€™re rendering large lists, grids, or charts
* Youâ€™re dealing with expensive calculations or heavy UI updates

However:

* If your component isnâ€™t slowâ€”just **optimize the code instead**.
* If youâ€™re loading data, consider `Suspense` and `startTransition`.

---

## ğŸ§ª Check Performance with React DevTools

Use the [React DevTools Profiler](https://react.dev/learn/debugging#react-developer-tools) to verify:

* Which components re-render when
* How long each render takes
* Whether memoization is preventing unnecessary updates

---

## ğŸ§  Final Tips for Concurrent Rendering

| Technique            | Use Case                                                    |
| -------------------- | ----------------------------------------------------------- |
| `useDeferredValue()` | Deprioritize rendering of large or slow updates             |
| `React.memo()`       | Prevent re-renders when props havenâ€™t changed               |
| `useMemo()`          | Avoid recalculating expensive logic unnecessarily           |
| `startTransition()`  | Mark updates as low-priority (especially for data fetching) |

---

## ğŸ”š Wrapping Up

Reactâ€™s concurrent rendering model gives you more control over **prioritizing user experience**. With tools like `useDeferredValue` and `memo`, you can balance performance and responsivenessâ€”even when your app needs to do heavy lifting.

If your app feels slow when rendering filtered results or lists, itâ€™s time to let React **pause, breathe, and catch up**. Defer the less important work, and give the user control center stage.

---

ğŸ“š **Further Reading**

* [React docs: `useDeferredValue`](https://react.dev/reference/react/useDeferredValue)
* [React Docs on Concurrent Features](https://react.dev/learn/synchronizing-with-effects#transitions-and-deferred-values)
* [React Keynote 2022 â€“ Demo of concurrency](https://youtu.be/FZ0cG47msEk?t=1155)

---
