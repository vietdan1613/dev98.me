---
title: "React Suspense: Optimizations"
category: React
author: Daniel Nguyen
tags: ['#ReactSuspense']
date: 2025-06-26
thumbnail: image.jpg
featured: true
---

**ğŸš€ Optimizing React Suspense: Crush Waterfalls, Preload Images, and Leverage Server Caching**

React Suspense opens up a powerful pattern for colocating data with the components that need it. 
But like any great power, it comes with risksâ€”and one of the biggest is the dreaded **waterfall**.

If you've ever wondered why your app feels slower than expected, you might be triggering unnecessary 
delays in your data loading. Let's explore how to avoid that.

---

## ğŸ’§ What's a Waterfall?

If you open your browser DevTools and look at the Network tab, youâ€™ll see a column called 
**â€œWaterfall.â€** That name isnâ€™t just visualâ€”it refers to how your appâ€™s requests are being sequenced.

A *bad* waterfall looks like this:

```
Request A --------> Response A
                     Request B --------> Response B
                                          Request C --------> Response C
```

Each request starts **after** the previous one finishes.

A *good* (parallel) waterfall looks like this:

```
Request A --------> Response A
Request B --------> Response B
Request C --------> Response C
```

All requests are made at the same time, reducing total wait time.

---

## âš ï¸ Why React Suspense Makes Waterfalls Easy (Too Easy)

React Suspense works by suspending the component **as soon as** a Promise is used. If your component 
triggers multiple `use()` calls in sequence, youâ€™ve already created a waterfall.

### ğŸ§¨ Bad: Sequential Fetching (Triggers Waterfall)

```tsx
function ProfileDetails({ username }: { username: string }) {
  const favoritesCount = use(getFavoritesCount(username))
  const friends = use(getFriends(username))
  return <div>{/* ... */}</div>
}
```

The second fetch wonâ€™t even begin until the first one resolves. Ouch.

---

## âœ… Solution: Trigger Promises Before `use`

Trigger all your data requests **before** suspending:

```tsx
function ProfileDetails({ username }: { username: string }) {
  const favoritesCountPromise = getFavoritesCount(username)
  const friendsPromise = getFriends(username)

  const favoritesCount = use(favoritesCountPromise)
  const friends = use(friendsPromise)

  return <div>{/* ... */}</div>
}
```

Now both network requests begin at the same time. ğŸš€

---

## ğŸ§± Hidden Waterfalls in Nested Components

Sometimes waterfalls sneak in when you separate concerns between parent and child components.

```tsx
function ProfilePage({ username }: { username: string }) {
  const userAvatar = use(getUserAvatar(username))
  return (
    <div>
      <Avatar url={userAvatar} />
      <ProfileDetails username={username} />
    </div>
  )
}
```

The `ProfileDetails` componentâ€™s data **wonâ€™t even begin to fetch** until the `ProfilePage` 
finishes suspending on `getUserAvatar`.

### âœ… Fix: Preload Promises in the Parent

```tsx
function ProfilePage({ username }: { username: string }) {
  getFavoritesCount(username) // start request early
  getFriends(username)

  const userAvatar = use(getUserAvatar(username))
  return (
    <div>
      <Avatar url={userAvatar} />
      <ProfileDetails username={username} />
    </div>
  )
}
```

By calling the data functions early (which return cached Promises), we avoid the waterfall.

---

## ğŸ›  Bonus: Build a `loadData` Helper

To make your parent code cleaner, attach a `loadData` method to your component:

```tsx
ProfileDetails.loadData = (username) => ({
  favoritesCountPromise: getFavoritesCount(username),
  friendsPromise: getFriends(username),
})
```

Use it like this:

```tsx
ProfileDetails.loadData(username)
```

This keeps your preloading strategy reusable and maintainable.

---

## ğŸ§  Why Not Just Use Props?

Yes, you could also pass Promises via props:

```tsx
<ProfileDetails
  favoritesCountPromise={favoritesCountPromise}
  friendsPromise={friendsPromise}
/>
```

But that spreads your data fetching logic all over the place. Instead, triggering 
fetches earlyâ€”then using `use()` where neededâ€”gives you both colocated logic and optimized performance.

---

## ğŸ–¼ï¸ Preloading Images to Avoid Visual Waterfalls

Another kind of waterfall happens with **images**.

Imagine this scenario:

* You click a new pokemon.
* React fetches the pokemon's data.
* After that, React renders `<img src="pokemon.jpg" />`, and only then does the browser start loading the image.

Thatâ€™s a **visual waterfall**.

### âœ… Fix: Preload the Image in Parallel

```tsx
function PokemonDetails({ name }: { name: string }) {
  preloadImage(`/img/${name}.jpg`)
  const pokemon = use(getPokemon(name))

  return (
    <>
      <PokemonImg src={`/img/${name}.jpg`} />
      {/* other pokemon data */}
    </>
  )
}
```

Now the image download begins as soon as we know the pokemonâ€™s nameâ€”not after rendering the image tag.

---

## ğŸŒ Server-Side: Cache-Control Headers

Suspense helps us optimize frontend performance. But donâ€™t forget your **backend**.

You can avoid redundant requests and improve refresh speed by leveraging HTTP caching.

### âœ… Add Cache Headers to API Responses

```http
Cache-Control: max-age=3600
```

This instructs the browser to cache the response for an hour.

If you have API endpoints like `/api/pokemon-details`, simply set this header on the response server-side:

```ts
res.setHeader("Cache-Control", "max-age=3600")
```

Just be sure the data is okay to cache and doesnâ€™t change too frequently.

---

## ğŸ§ª Putting It All Together: Avoid Waterfalls Like a Pro

Letâ€™s recap what youâ€™ve learned:

| Problem               | Cause                               | Fix                         |
| --------------------- | ----------------------------------- | --------------------------- |
| Data waterfalls       | Fetch inside `use()` calls          | Trigger Promises early      |
| Nested waterfalls     | Child fetches after parent suspends | Preload in parent           |
| Image loading delays  | `<img src>` starts late             | Use `preloadImage()`        |
| Lost cache on refresh | Cache lost on reload                | Use `Cache-Control` headers |

---

## ğŸ¤– What About React 19?

Good news: **React 19 improves automatic parallel loading.** Some of the waterfall issues described here have been fixed behind the scenes.

But itâ€™s still important to understand:

* How waterfalls happen
* How to spot them in DevTools
* How to preload resources like images
* How to leverage server-side cache for persistency

---

## ğŸš¢ TL;DR: Build Faster React Apps

React Suspense gives you incredible powerâ€”but if you don't understand waterfalls, you might end up building a slower app than intended.

Avoid waterfalls by:

* Triggering all data fetches early
* Preloading images
* Using `Cache-Control` headers on your API
* Using tooling like Remix that avoids waterfalls for you

Stay sharp, preload smart, and render fast. ğŸ§ ğŸ’¥

---