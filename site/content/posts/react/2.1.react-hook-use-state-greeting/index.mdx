---
title: "React Hooks: Managing UI State"
category: React
author: Daniel Nguyen
tags: ['#ReactHooks']
date: 2025-06-02
thumbnail: image.jpg
featured: true
---

**🎯 Mastering UI State Management in React — A Complete Beginner’s Guide**

React is all about building interactive, dynamic user interfaces. Whether you're creating a simple counter app or a complex form, at the heart of every React app lies **state**—a mechanism for tracking data that changes over time.

In this blog, we'll walk through the fundamentals of managing UI state in React, learn about **hooks**, control form inputs, derive values intelligently, and even optimize how state is initialized. Let’s dive in!

---

## 🔄 Understanding the UI Lifecycle in React

Dynamic applications update the UI based on user interaction. Here’s the basic flow:

**Render → Setup the DOM → User Interacts → State Changes → Re-render → Update the DOM → Back to User Interaction**

![example](./1.png 'example')

This loop is central to how React works. When a user does something (like clicking a button), your app should respond by updating its internal state, which then causes a **re-render** that updates the UI.

---

## 🪝 What Are Hooks?

React provides special functions called **hooks** that allow you to manage state and side effects inside functional components.

Here are some of the most common hooks:

* `useState` — for managing component state
* `useRef` — for referencing DOM elements or values
* `use` — for suspending/rendering with async data (experimental)
* `useReducer` — for complex state logic
* `useEffect` — for side effects like fetching data

Each of these hooks behaves differently. For example, `useState` returns a pair: the current value and a function to update it.

---

## 🧮 Your First State: The Counter Example

Here’s a basic counter component using `useState`:

```tsx
function Counter() {
	const [count, setCount] = useState(0)
	const increment = () => setCount(count + 1)
	return <button onClick={increment}>{count}</button>
}
```

### How It Works:

* We call `useState(0)`, which sets `count` to `0` initially.
* When the button is clicked, `increment` is called, which updates the state via `setCount`.
* React re-renders the component with the new count.

👉 **Note:** The initial value passed to `useState` is only used once—on the **first render**. After that, React manages the value internally.

---

## 🔍 Controlling Form Inputs with State

To make UI truly dynamic, we often need to **control input elements** using state.

Let’s say you're building a blog search page with an input field and checkboxes to filter results. You want to:

1. Update the input value as the user types.
2. Automatically fill the input when a checkbox is clicked.

This is called a **controlled input**, and you achieve it like this:

```tsx
const [query, setQuery] = useState("")

<input value={query} onChange={e => setQuery(e.target.value)} />
```

For checkboxes, update the input programmatically when the user clicks them:

```tsx
<input type="checkbox" onChange={() => setQuery("example")} />
```

---

## 🧠 Deriving State Instead of Duplicating It

Let’s say you want to display whether a counter is odd or even. You *could* keep a second state like this:

```tsx
const [count, setCount] = useState(0)
const [isEven, setIsEven] = useState(true)
```

…but that leads to **duplicate state**, which can get out of sync.

💡 **Better approach:** *derive* the value from existing state.

```tsx
const [count, setCount] = useState(0)
const isEven = count % 2 === 0
```

Derived values keep your state logic clean and bug-free.

---

## 🔗 Initializing State from the URL

Imagine users want to share a search result page like:

```
https://example.com/search?query=cat+dog
```

You want to initialize your component’s state with the `query` from the URL. Here's how:

```tsx
const params = new URLSearchParams(window.location.search)
const initialQuery = params.get('query') ?? ''
const [query, setQuery] = useState(initialQuery)
```

Now the component will reflect the search query from the URL!

---

## ⚙️ Performance Tip: Lazy Initialization

What if computing the initial state value is expensive?

Instead of doing this:

```tsx
const [val, setVal] = useState(expensiveComputation())
```

You can do this:

```tsx
const [val, setVal] = useState(expensiveComputation)
```

Passing a function tells React to **only run it once**—on the first render. This is known as **lazy initialization**, and it can save performance in complex apps.

---

## ✅ Summary

Here’s a recap of what we learned about managing UI state in React:

| Concept               | Description                                                            |
| --------------------- | ---------------------------------------------------------------------- |
| `useState`            | Main hook for tracking and updating state in components                |
| Controlled Inputs     | Use state with `value` and `onChange` for dynamic form inputs          |
| Derived State         | Compute values from existing state instead of tracking them separately |
| Initializing from URL | Use `URLSearchParams` to grab query data on page load                  |
| Lazy Initialization   | Pass a function to `useState` to avoid unnecessary computation         |

---

## 📚 Further Learning

* [React Docs: `useState`](https://react.dev/reference/react/useState)
* [Controlling an Input with State](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
* [Shawn Wang – Getting Closure on Hooks](https://www.swyx.io/getting-closure-on-hooks/)

---

By understanding how React state works and applying these best practices, you’ll be able to build more reliable, user-friendly apps. Happy coding! 🚀

---

Let me know if you'd like this formatted for your blog CMS (e.g. Markdown with frontmatter, styled HTML, etc.) or tailored with code snippets for your specific use case.

