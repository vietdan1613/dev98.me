---
title: "ğŸŒ React Fundamental: Rendering Arrays"
category: React
author: Daniel Nguyen
tags: ['#ReactFundamental']
date: 2025-05-11
thumbnailText: React Fundamental
---

**ğŸ”‘ Mastering the `key` Prop in React: Why It Matters When Rendering Lists**

When building UIs with React, youâ€™ll often find yourself rendering lists of elements. It seems simple at first, but as your app grows more interactive, especially when elements hold **state** (like form inputs), youâ€™ll likely run into subtle bugs if you're not handling lists correctly.

One such subtle-but-important detail is Reactâ€™s **`key` prop** â€” a small addition that makes a huge difference.

In this post, weâ€™ll explore:

* Why React needs the `key` prop when rendering arrays
* What can go wrong if you forget it
* The best practices for choosing `key` values
* A cool trick: using the `key` prop to reset component state

---

## ğŸ§± Rendering Lists in React

Hereâ€™s a basic list in React:

```tsx
const ui = (
  <ul>
    <li>One</li>
    <li>Two</li>
    <li>Three</li>
  </ul>
)
```

This works just fine. But if you're dynamically rendering a list, youâ€™d likely use `.map()`:

```tsx
const list = ['One', 'Two', 'Three']

const ui = (
  <ul>
    {list.map(listItem => (
      <li>{listItem}</li>
    ))}
  </ul>
)
```

React will render the same HTML, but internally something important is happening.

Letâ€™s extract this into variables to understand it better:

```tsx
const list = ['One', 'Two', 'Three']
const listUI = list.map(listItem => <li>{listItem}</li>)
const ui = <ul>{listUI}</ul>
```

Here, `listUI` is just an **array of React elements**. And rendering an array like this is totally valid in React. But thereâ€™s a **catch**.

---

## âš ï¸ What Happens When the List Changes?

When you update the list (e.g., by adding or removing an item), React needs to figure out **which elements are new, which are removed, and which ones should stay the same**.

But React canâ€™t read your mind.

From Reactâ€™s perspective, it sees two arrays â€” one from before the change and one after â€” and tries to match up the elements. Without more information, it just guesses based on order.

This usually works fine... until you introduce **stateful elements** â€” like an `<input />` element.

---

## ğŸ˜µ The Bug You Might Encounter

Imagine each list item has an input field:

```tsx
<ul>
  {list.map(item => (
    <li>
      <label>{item}</label>
      <input defaultValue={item} />
      <button onClick={() => removeItem(item)}>Remove</button>
    </li>
  ))}
</ul>
```

Try this:

1. Type something in one of the input fields.
2. Click "Remove" on the **first** item.

You might notice that the input values **jump around** or stay filled with the wrong content.

Why? Because React reused the DOM nodes and didnâ€™t realize which specific item was removed.

---

## âœ… The Fix: Use the `key` Prop

To solve this, React gives us the `key` prop. Itâ€™s a special prop (you donâ€™t get access to it in the component) that **uniquely identifies** each element in a list.

When React sees the `key`, it can confidently track which item is which â€” even when items are added or removed.

```tsx
<ul>
  {list.map(item => (
    <li key={item.id}>
      <label>{item.name}</label>
      <input defaultValue={item.name} />
      <button onClick={() => removeItem(item.id)}>Remove</button>
    </li>
  ))}
</ul>
```

Here, `item.id` should be a **unique and stable value**. This way, React doesnâ€™t get confused when re-rendering the list.

---

## ğŸ§  Why Not Use Index?

You might think:

> "Can I just use the array index as a key?"

```tsx
list.map((item, index) => <li key={index}>{item}</li>)
```

React will stop complaining, but **youâ€™re still at risk of bugs**.

Using the index doesnâ€™t help React when the list changes â€” if you insert or delete items, the indices shift, and React may reuse DOM elements incorrectly.

So while it **silences the warning**, it doesnâ€™t actually solve the problem.

---

## ğŸ¯ Recap: When and How to Use `key`

* Always use a `key` when rendering a list of elements.
* The `key` should be:

  * **Unique** among siblings
  * **Stable** over time (doesn't change across renders)
* Prefer unique IDs (e.g., `user.id`, `product.sku`)
* **Avoid using array indices** as keys, unless the list is static and never changes

---

## âœ¨ Bonus Trick: Resetting State with `key`

Did you know you can use `key` to force a React component to reset?

Imagine this:

```tsx
<MyComponent key={someUniqueKey} />
```

If `someUniqueKey` changes, React **unmounts and remounts** the component from scratch, wiping any internal state.

This is useful when you want to **reset an input form**, **restart an animation**, or **clear state** on purpose.

Example:

```tsx
<button onClick={() => setKey(prev => prev + 1)}>Reset</button>
<MyForm key={key} />
```

Clicking the button resets the form component because the key changed. A neat and effective trick!

---

## ğŸ“˜ Want to Learn More?

* [Understanding Reactâ€™s `key` prop â€“ Kent C. Dodds](https://kentcdodds.com/blog/understanding-reacts-key-prop)
* [Why React needs a key prop â€“ EpicReact.dev](https://epicreact.dev/why-react-needs-a-key-prop)

These will give you an even deeper understanding of whatâ€™s happening under the hood.

---

## ğŸ§‘â€ğŸ« Conclusion

Reactâ€™s `key` prop might seem small, but it plays a **critical** role in efficient and correct UI updates. Without it, React may make incorrect assumptions about your list items â€” especially when they manage their own state.

Next time you render a list in React, remember:

> **If you're mapping over an array, you need a `key`. Make it unique. Make it stable.**

Happy coding! âš›ï¸
