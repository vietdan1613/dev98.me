---
title: "React Fundamental: TypeScript"
category: React
author: Daniel Nguyen
tags: ['#ReactFundamental']
date: 2025-05-06
thumbnail: image.jpg
featured: true
---

**ğŸ§  Mastering TypeScript in React: From Red Squiggles to Confidence**

When you're building maintainable and scalable React applications, **TypeScript** is one of the most valuable tools in your developer toolbox. It offers safety, productivity, and clarity â€” even if it seems strict or frustrating at first.

But remember:

> **"TypeScript is not making your life terrible. It's just showing you how terrible your life already is."**
> â€“ [Kent C. Dodds](https://twitter.com/kentcdodds/status/1763606063394496633)

Letâ€™s walk through how to use TypeScript effectively in React â€” from typing components and props, to improving developer experience with narrowing, deriving, and even satisfying types. ğŸ¦º

---

## ğŸš€ Why TypeScript?

```tsx
function greet(user) {
  return `Hello, ${user.name.toUpperCase()}!`;
}

const result = greet({ age: 25 });
// âŒ Runtime Error: Cannot read property 'toUpperCase' of undefined
```

Think of TypeScript as a brutally honest friend. It points out the problems before your users run into them â€” the â€œspinach in your teethâ€ of your codebase.

Once you get past the initial learning curve, TypeScript becomes a key ally in reducing bugs and making your codebase easier to navigate and refactor.

---

## ğŸ› ï¸ Typing Functions

Letâ€™s start with the basics: typing regular functions.

```ts
// JS function
function getName(user) {
  return user.name ?? 'Unknown'
}

// With types
type User = { name?: string }
function getName(user: User): string {
  return user.name ?? 'Unknown'
}
```

TypeScript will infer return types in many cases, but specifying them makes your code more readable and robust.

ğŸ“˜ **Learn More:** [TypeScript Function Syntaxes](https://kentcdodds.com/blog/typescript-function-syntaxes)

---

## âš›ï¸ Typing React Components

React components are just functions. That means you can type them the same way:

```tsx
type MessageProps = { children: React.ReactNode }

function Message({ children }: MessageProps) {
  return <div className="message">{children}</div>
}
```

You can also inline props or destructure them for conciseness:

```tsx
function Message({ children }: { children: React.ReactNode }) {
  return <div className="message">{children}</div>
}
```

ğŸ“˜ **Resource:** [React + TypeScript Cheatsheets](https://github.com/typescript-cheatsheets/react)

---

## â• Narrowing Types for Safer Props

Letâ€™s say we have a `Calculator` component:

```tsx
<Calculator left={2} operator="**" right={3} /> // ğŸ’¥ runtime error!
```

The problem? The `operator` prop is typed as `string`, which is too broad.

Instead, narrow it:

```ts
type Operator = '+' | '-' | '*' | '/'
```

Now TypeScript will complain if someone tries to use an unsupported operator.

```tsx
type CalculatorProps = {
  left: number
  right: number
  operator: Operator
}
```

This makes your component API **safer and more discoverable**.

---

## ğŸ§ª Deriving Types with `typeof` and `keyof`

Avoid repeating yourself by deriving prop types directly from objects.

```ts
const operations = {
  '+': (a: number, b: number) => a + b,
  '-': (a: number, b: number) => a - b,
  '*': (a: number, b: number) => a * b,
  '/': (a: number, b: number) => a / b,
}

type Operator = keyof typeof operations
```

Now, if you add a new operation to the `operations` object, TypeScript automatically includes it in the `Operator` type.

ğŸ“˜ [More on `typeof`](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
ğŸ“˜ [More on `keyof`](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)

---

## âš™ï¸ Setting Default Props

Want to make props optional with defaults?

```tsx
type CalculatorProps = {
  left?: number
  right?: number
  operator?: Operator
}

function Calculator({
  left = 0,
  right = 0,
  operator = '+',
}: CalculatorProps) {
  const result = operations[operator](left, right)
  return <div>{result}</div>
}
```

Now, this is valid:

```tsx
<Calculator /> // Renders 0 + 0 = 0
```

ğŸ“˜ [Destructuring with Defaults](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values_2)

---

## ğŸ” Reducing Duplication with `Record`

Instead of typing each operation function manually:

```ts
const operations = {
  '+': (a: number, b: number) => a + b,
  '-': (a: number, b: number) => a - b,
  // ...
}
```

Use `Record`:

```ts
type OperationFn = (a: number, b: number) => number
type Operator = '+' | '-' | '*' | '/'

const operations: Record<Operator, OperationFn> = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b,
}
```

This avoids repeating function types, and helps TypeScript enforce structure.

ğŸ“˜ [Record Utility Type](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)

---

## âœ… Enforcing Correct Values with `satisfies`

Using `Record` works, but can sometimes **widen** types. You can fix that with `satisfies`:

```ts
const operations = {
  '+': (a, b) => a + b,
  '-': (a, b) => a - b,
  '*': (a, b) => a * b,
  '/': (a, b) => a / b,
} satisfies Record<Operator, OperationFn>
```

This ensures:

* All required keys are present
* Function signatures match
* Types arenâ€™t unnecessarily widened

ğŸ“˜ [TypeScript `satisfies` operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)

---

## ğŸ§¯ When TypeScript Gets in the Way

Sometimes, TypeScript can slow you down â€” and thatâ€™s OK. You can ask it to hush temporarily:

```ts
// @ts-expect-error Iâ€™ll fix this later
make.magic()
```

Donâ€™t let the red squiggles keep you from making progress. TypeScript is here to help â€” not block you.

---

## ğŸ§  Wrap-Up

TypeScript makes your React applications more robust, self-documenting, and maintainable. Mastering it takes time, but step by step, youâ€™ll gain confidence.

Hereâ€™s what you should walk away with:

* âœ… Typing props is just like typing function arguments.
* ğŸ§  Narrowing union types prevents runtime errors.
* ğŸ§ª `typeof` + `keyof` helps derive types without repetition.
* ğŸ§° `Record` reduces redundancy.
* âœ… `satisfies` enforces constraints without widening types.
* â›‘ï¸ You can still move forward with `@ts-expect-error` when needed.

ğŸ“š Keep these references handy:

* [React + TypeScript Cheatsheets](https://github.com/typescript-cheatsheets/react)
* [Total TypeScript](https://www.totaltypescript.com/)
* [Kent C. Dodds: TypeScript Blog Series](https://kentcdodds.com/blog)

---

> ğŸ’¬ **"You donâ€™t have to get it perfect. Just get it going, and let TypeScript help guide you from there."**


