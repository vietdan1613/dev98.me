---
title: "React Testing: Testing with context and a custom render method"
category: React
author: Daniel Nguyen
tags: ['#ReactTesting']
date: 2025-07-27
thumbnail: image.jpg
featured: true
---

**ğŸ¨ Testing React Components with Context & Custom Render Methods**

React context is a powerful feature for sharing values across your component treeâ€”like themes, authentication status, or router state. But once you start writing tests for components that use context, things can get repetitive fast.

> ğŸ˜© "Why do I have to wrap my component with the provider **every time** I test?"

Letâ€™s solve that problem by learning how to **test context-driven components efficiently** using a **custom render method** with React Testing Library.

---

## ğŸ§  The Context Problem in Tests

Letâ€™s say youâ€™re testing a component that uses a `ThemeContext`. To render it properly, you need to wrap it in the `ThemeProvider`.

```js
import {render} from '@testing-library/react'
import {ThemeProvider} from '../context/theme'

render(
  <ThemeProvider>
    <ComponentToTest />
  </ThemeProvider>,
)
```

That works! But what if you want to rerender the component with updated props? Youâ€™ll have to **repeat the wrapper** again:

```js
const {rerender} = render(
  <ThemeProvider>
    <ComponentToTest />
  </ThemeProvider>
)

rerender(
  <ThemeProvider>
    <ComponentToTest newProp={true} />
  </ThemeProvider>
)
```

ğŸ“‰ This creates **boilerplate** and tightly couples your test logic to the implementation.

---

## ğŸ§ª Solution: Use the `wrapper` Option

React Testing Library allows you to pass a `wrapper` component when calling `render`. This ensures both the **initial render** and **all rerenders** are wrapped consistently.

```js
function Wrapper({children}) {
  return <ThemeProvider>{children}</ThemeProvider>
}

const {rerender} = render(<ComponentToTest />, {wrapper: Wrapper})

rerender(<ComponentToTest newProp={true} />)
```

âœ¨ This way, your tests become simpler and more maintainable.

ğŸ“š Learn more: [React Testing Library â€“ wrapper](https://testing-library.com/docs/react-testing-library/api#wrapper)

---

## ğŸ›  Going Further: Custom Render Function

We can take this idea further by **creating our own `render` function** that automatically wraps components with all necessary providersâ€”just like your app does.

```js
// test-utils.js
import {render as rtlRender} from '@testing-library/react'
import {ThemeProvider} from '../context/theme'

function Wrapper({children, theme = 'light'}) {
  return <ThemeProvider initialTheme={theme}>{children}</ThemeProvider>
}

function render(ui, {theme, ...options} = {}) {
  return rtlRender(ui, {
    wrapper: ({children}) => <Wrapper theme={theme}>{children}</Wrapper>,
    ...options,
  })
}

export * from '@testing-library/react'
export {render}
```

Now you can write clean tests like this:

```js
import {render, screen} from '../test/test-utils'
import EasyButton from '../components/easy-button'

test('renders with light theme styles', () => {
  render(<EasyButton />, {theme: 'light'})
  expect(screen.getByRole('button')).toHaveStyle({
    backgroundColor: 'white',
    color: 'black',
  })
})
```

And test the dark theme with minimal changes:

```js
test('renders with dark theme styles', () => {
  render(<EasyButton />, {theme: 'dark'})
  expect(screen.getByRole('button')).toHaveStyle({
    backgroundColor: 'black',
    color: 'white',
  })
})
```

---

## ğŸ’¯ Extra Credit

### 1. âœ… Test the dark theme

Duplicate your light theme test, swap out `theme: 'dark'`, and update the style assertions. This ensures your context logic behaves correctly across variations.

### 2. âœ… Create a `render` helper

Create a `render` method in your own `test-utils.js` file that automatically wraps components with the needed context providers. This centralizes setup logic, making all future tests easier to write.

### 3. âœ… Use shared test utilities

If you're working in a larger app, you likely already have a shared `render` helper in a file like `test/test-utils.js`. Just **import from there** instead of `@testing-library/react`:

```js
// âŒ Don't do this
import {render} from '@testing-library/react'

// âœ… Do this
import {render} from '../test/test-utils'
```

This ensures every test uses the same app-wide providersâ€”like router, theme, or authenticationâ€”without extra boilerplate.

---

## ğŸ” Recap

| Concept                            | Benefit                                                  |
| ---------------------------------- | -------------------------------------------------------- |
| Wrap components with context       | Ensures components function as they do in production     |
| Use `wrapper` option               | Allows rerendering without duplicating providers         |
| Create a `test-utils.js` file      | DRYs up test setup across your test suite                |
| Support theme/auth/router context  | Fully simulates real-world usage for more accurate tests |
| Add options like `{theme: 'dark'}` | Makes tests easier to read and adapt                     |

---

## ğŸ“‹ Elaboration and Feedback

If you want to reflect on what you've learned and reinforce your understanding, take a moment to fill out this quick feedback form:

ğŸ‘‰ [Testing with Context & Custom Render â€“ Feedback Form](https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=07%3A%20testing%20with%20context%20and%20a%20custom%20render%20method&em=)

---

## ğŸ‘‹ Final Thoughts

Writing tests that resemble how your app is used in the real world is always a win. With context, that means **rendering your components with the right providers**, but doing it in a way thatâ€™s clean, DRY, and expressive.

Your tests should focus on behaviorâ€”not implementation details. A custom render utility lets you do just that.