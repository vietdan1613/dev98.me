---
title: "Next.js: Caching"
category: NextJS
author: Daniel Nguyen
tags: ['#tailwindcss']
date: 2025-12-12
thumbnailText: Crash Course
---

Caching has always been a crucial part of web performance. But in **Next.js 16**, caching has been completely reimagined.
It’s smarter, more flexible, and gives you full control over how your app reuses data — without needing to pick SSR, SSG, ISR, or PPR manually.

This guide walks you through:

* What caching is
* The three layers of caching
* The new caching model in Next 16
* `use cache` and component-level caching
* Cache lifetimes
* Cache tags & invalidation
* Revalidate vs revalidateTag
* How caching affects Partial Pre-Rendering (PPR)

Let’s get into it.

---

# **1. What Is Caching?**

**Caching** means storing data temporarily so you don’t have to refetch or rebuild it on every request.

This reduces:

* API calls
* Build time
* CPU time
* Page rendering cost
* End-user latency

Better caching = faster apps.

---

# **2. The Three Layers of Caching in Next.js**

Next.js uses caching across **multiple layers**:

### **1️⃣ Browser Cache**

Stores static assets (JS, CSS, images) locally.
Improves repeat visits and navigations.

### **2️⃣ Server Cache**

Stores:

* Pre-rendered pages
* Prefetched route segments
* Render results

Ensures instant navigation and low server load.

### **3️⃣ Data Cache**

Stores fetch results to avoid duplicate network calls.
Especially important for React Server Components.

All three layers work together to deliver truly instant-feeling web apps.

---

# **3. The New Caching Mindset in Next.js 16**

In older versions, you explicitly chose:

* SSR
* SSG
* ISR
* PPR

In **Next.js 16**, those aren't modes anymore — they’re **outcomes**.

Now, you simply define caching behavior and Next.js decides the rendering strategy automatically.

> **Rendering becomes the result of the caching you define.**
> Not the other way around.

---

# **4. Enabling the New Caching System**

In `next.config.js`:

```ts
export default {
  experimental: {
    cache: true,
  },
};
```

Caching is disabled by default to avoid breaking changes.
You must opt in.

---

# **5. The `use cache` Directive**

Just like `use client` or `use server`, you can now mark entire components or routes as cacheable.

At the **file level**:

```ts
"use cache";

export default function Page() {
  return <h1>My cached page</h1>;
}
```

At the **component level**:

```ts
"use cache";

export function Sidebar() {
  return <aside>Cached Sidebar</aside>;
}
```

At the **function level**:

```ts
"use cache";

async function getData() {
  const res = await fetch("https://example.com");
  return res.json();
}
```

### What this does:

* Pre-renders the output
* Stores it in memory
* Reuses it until it expires
* Revalidates automatically (default: **15 minutes**)

---

# **6. Cache Lifetime — `cacheLife()`**

You can fine-tune how long something stays cached.

Example:

```ts
"use cache";
import { cacheLife } from "next/cache";

cacheLife("hours");
```

### Built-in lifetime options:

* `"seconds"`
* `"minutes"`
* `"hours"`
* `"days"`

Or define a custom lifetime in `next.config.js`.

---

# **7. Cache Tags — Grouped Caching**

Tags let you group cached items so you can invalidate them together.

```ts
import { cacheTag } from "next/cache";

cacheTag("books");
```

This is useful when:

* Updating a DB record
* Publishing content
* Deleting a user
* Syncing external APIs

---

# **8. Invalidation — `revalidate` and `revalidateTag`**

### **Revalidate everything under a tag:**

```ts
import { revalidateTag } from "next/cache";

revalidateTag("books");
```

### **Revalidate a specific route or fetch call:**

```ts
import { revalidate } from "next/cache";

revalidate("/dashboard");
```

### Difference:

| Method          | Purpose                               |
| --------------- | ------------------------------------- |
| `revalidate`    | Refresh a specific resource           |
| `revalidateTag` | Refresh everything labeled with a tag |

---

# **9. How This Affects PPR (Partial Pre-Rendering)**

Previously, you needed:

```ts
export const experimental_ppr = true;
```

Not anymore.

With caching enabled:

* Static parts of a page marked with `use cache` are pre-rendered
* Dynamic parts stream in automatically using React Suspense
* You get PPR **out of the box**

No flags.
No complexity.
Just smart defaults.

---

# **10. The New Caching Philosophy**

The big shift in Next.js 16:

* **Forget SSR, SSG, ISR, PPR as settings**
* **Think only about what should be cached and for how long**
* **Rendering strategy becomes automatic**

### Benefits:

✔ Simpler mental model
✔ Faster apps
✔ Clearer responsibilities
✔ More granular control
✔ Easier invalidation

It feels new at first, but once you get used to it, it becomes incredibly intuitive.

---

# **Final Thoughts**

Caching in Next.js 16 is a major leap forward. With:

* `use cache`
* `cacheLife()`
* cache tags
* revalidation tools
* built-in PPR
* simplified mental model

…you get complete control over performance while writing less code.

This is a huge part of mastering modern Next.js — and you're now ready to use it in real applications.

